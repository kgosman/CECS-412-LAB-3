
TinyOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000260  00800100  00000ee6  00000f7a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000ee6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000015  00800360  00800360  000011da  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000011da  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000120c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000a8  00000000  00000000  00001250  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000143b  00000000  00000000  000012f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ab8  00000000  00000000  00002733  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000c40  00000000  00000000  000031eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001b0  00000000  00000000  00003e2c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005d3  00000000  00000000  00003fdc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000417  00000000  00000000  000045af  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000078  00000000  00000000  000049c6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 87 00 	jmp	0x10e	; 0x10e <__ctors_end>
   4:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
   8:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
   c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  10:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  14:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  18:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  1c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  20:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  24:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  28:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  2c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  30:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  34:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  38:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  3c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  40:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  44:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  48:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  4c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  50:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  54:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  58:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  5c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  60:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  64:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  68:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  6c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  70:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  74:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  78:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  7c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  80:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  84:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  88:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  8c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  90:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  94:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  98:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  9c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  a0:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  a4:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  a8:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  ac:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  b0:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  b4:	08 00       	.word	0x0008	; ????
  b6:	00 00       	nop
  b8:	be 92       	st	-X, r11
  ba:	24 49       	sbci	r18, 0x94	; 148
  bc:	12 3e       	cpi	r17, 0xE2	; 226
  be:	ab aa       	std	Y+51, r10	; 0x33
  c0:	aa 2a       	or	r10, r26
  c2:	be cd       	rjmp	.-1156   	; 0xfffffc40 <__eeprom_end+0xff7efc40>
  c4:	cc cc       	rjmp	.-1640   	; 0xfffffa5e <__eeprom_end+0xff7efa5e>
  c6:	4c 3e       	cpi	r20, 0xEC	; 236
  c8:	00 00       	nop
  ca:	00 80       	ld	r0, Z
  cc:	be ab       	std	Y+54, r27	; 0x36
  ce:	aa aa       	std	Y+50, r10	; 0x32
  d0:	aa 3e       	cpi	r26, 0xEA	; 234
  d2:	00 00       	nop
  d4:	00 00       	nop
  d6:	bf 00       	.word	0x00bf	; ????
  d8:	00 00       	nop
  da:	80 3f       	cpi	r24, 0xF0	; 240
  dc:	00 00       	nop
  de:	00 00       	nop
  e0:	00 08       	sbc	r0, r0
  e2:	41 78       	andi	r20, 0x81	; 129
  e4:	d3 bb       	out	0x13, r29	; 19
  e6:	43 87       	std	Z+11, r20	; 0x0b
  e8:	d1 13       	cpse	r29, r17
  ea:	3d 19       	sub	r19, r13
  ec:	0e 3c       	cpi	r16, 0xCE	; 206
  ee:	c3 bd       	out	0x23, r28	; 35
  f0:	42 82       	std	Z+2, r4	; 0x02
  f2:	ad 2b       	or	r26, r29
  f4:	3e 68       	ori	r19, 0x8E	; 142
  f6:	ec 82       	std	Y+4, r14	; 0x04
  f8:	76 be       	out	0x36, r7	; 54
  fa:	d9 8f       	std	Y+25, r29	; 0x19
  fc:	e1 a9       	ldd	r30, Z+49	; 0x31
  fe:	3e 4c       	sbci	r19, 0xCE	; 206
 100:	80 ef       	ldi	r24, 0xF0	; 240
 102:	ff be       	out	0x3f, r15	; 63
 104:	01 c4       	rjmp	.+2050   	; 0x908 <Command+0x6>
 106:	ff 7f       	andi	r31, 0xFF	; 255
 108:	3f 00       	.word	0x003f	; ????
 10a:	00 00       	nop
	...

0000010e <__ctors_end>:
 10e:	11 24       	eor	r1, r1
 110:	1f be       	out	0x3f, r1	; 63
 112:	cf ef       	ldi	r28, 0xFF	; 255
 114:	d8 e0       	ldi	r29, 0x08	; 8
 116:	de bf       	out	0x3e, r29	; 62
 118:	cd bf       	out	0x3d, r28	; 61

0000011a <__do_copy_data>:
 11a:	13 e0       	ldi	r17, 0x03	; 3
 11c:	a0 e0       	ldi	r26, 0x00	; 0
 11e:	b1 e0       	ldi	r27, 0x01	; 1
 120:	e6 ee       	ldi	r30, 0xE6	; 230
 122:	fe e0       	ldi	r31, 0x0E	; 14
 124:	02 c0       	rjmp	.+4      	; 0x12a <__do_copy_data+0x10>
 126:	05 90       	lpm	r0, Z+
 128:	0d 92       	st	X+, r0
 12a:	a0 36       	cpi	r26, 0x60	; 96
 12c:	b1 07       	cpc	r27, r17
 12e:	d9 f7       	brne	.-10     	; 0x126 <__do_copy_data+0xc>

00000130 <__do_clear_bss>:
 130:	23 e0       	ldi	r18, 0x03	; 3
 132:	a0 e6       	ldi	r26, 0x60	; 96
 134:	b3 e0       	ldi	r27, 0x03	; 3
 136:	01 c0       	rjmp	.+2      	; 0x13a <.do_clear_bss_start>

00000138 <.do_clear_bss_loop>:
 138:	1d 92       	st	X+, r1

0000013a <.do_clear_bss_start>:
 13a:	a5 37       	cpi	r26, 0x75	; 117
 13c:	b2 07       	cpc	r27, r18
 13e:	e1 f7       	brne	.-8      	; 0x138 <.do_clear_bss_loop>
 140:	0e 94 ad 04 	call	0x95a	; 0x95a <main>
 144:	0c 94 71 07 	jmp	0xee2	; 0xee2 <_exit>

00000148 <__bad_interrupt>:
 148:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000014c <Mega328P_Init>:
.section ".text"			//student comment here

//Mo
.global Mega328P_Init
Mega328P_Init:
		ldi	r16,0x07		;PB0(R*W),PB1(RS),PB2(E) as fixed outputs
 14c:	07 e0       	ldi	r16, 0x07	; 7
		out	DDRB,r16		//student comment here
 14e:	04 b9       	out	0x04, r16	; 4
		ldi	r16,0			//student comment here
 150:	00 e0       	ldi	r16, 0x00	; 0
		out	PORTB,r16		//student comment here
 152:	05 b9       	out	0x05, r16	; 5
		out	U2X0,r16		;initialize UART, 8bits, no parity, 1 stop, 9600
 154:	01 b9       	out	0x01, r16	; 1
		ldi	r17,0x0			//student comment here
 156:	10 e0       	ldi	r17, 0x00	; 0
		ldi	r16,0x67		//student comment here
 158:	07 e6       	ldi	r16, 0x67	; 103
		sts	UBRR0H,r17		//student comment here
 15a:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		sts	UBRR0L,r16		//student comment here
 15e:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		ldi	r16,24			//student comment here
 162:	08 e1       	ldi	r16, 0x18	; 24
		sts	UCSR0B,r16		//student comment here
 164:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		ldi	r16,6			//student comment here
 168:	06 e0       	ldi	r16, 0x06	; 6
		sts	UCSR0C,r16		//student comment here
 16a:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		ldi r16,0x87		//initialize ADC
 16e:	07 e8       	ldi	r16, 0x87	; 135
		sts	ADCSRA,r16		//student comment here
 170:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		ldi r16,0x40		//student comment here
 174:	00 e4       	ldi	r16, 0x40	; 64
		sts ADMUX,r16		//student comment here
 176:	00 93 7c 00 	sts	0x007C, r16	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
		ldi r16,0			//student comment here
 17a:	00 e0       	ldi	r16, 0x00	; 0
		sts ADCSRB,r16		//student comment here
 17c:	00 93 7b 00 	sts	0x007B, r16	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
		ldi r16,0xFE		//student comment here
 180:	0e ef       	ldi	r16, 0xFE	; 254
		sts DIDR0,r16		//student comment here
 182:	00 93 7e 00 	sts	0x007E, r16	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
		ldi r16,0xFF		//student comment here
 186:	0f ef       	ldi	r16, 0xFF	; 255
		sts DIDR1,r16		//student comment here
 188:	00 93 7f 00 	sts	0x007F, r16	; 0x80007f <__TEXT_REGION_LENGTH__+0x7e007f>
		ret					//student comment here
 18c:	08 95       	ret

0000018e <LCD_Write_Command>:
	
//Kaden
.global LCD_Write_Command
LCD_Write_Command:
	call	UART_Off		//student comment here
 18e:	0e 94 04 01 	call	0x208	; 0x208 <UART_Off>
	ldi		r16,0xFF		;PD0 - PD7 as outputs
 192:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		//student comment here
 194:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		//student comment here
 196:	00 91 62 03 	lds	r16, 0x0362	; 0x800362 <DATA>
	out		PORTD,r16		//student comment here
 19a:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,4			//student comment here
 19c:	04 e0       	ldi	r16, 0x04	; 4
	out		PORTB,r16		//student comment here
 19e:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 1a0:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
	ldi		r16,0			//student comment here
 1a4:	00 e0       	ldi	r16, 0x00	; 0
	out		PORTB,r16		//student comment here
 1a6:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 1a8:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
	call	UART_On			//student comment here
 1ac:	0e 94 fe 00 	call	0x1fc	; 0x1fc <UART_On>
	ret						//student comment here
 1b0:	08 95       	ret

000001b2 <LCD_Delay>:

.global LCD_Delay
LCD_Delay:
	ldi		r16,0xFA		//student comment here
 1b2:	0a ef       	ldi	r16, 0xFA	; 250

000001b4 <D0>:
D0:	ldi		r17,0xFF		//student comment here
 1b4:	1f ef       	ldi	r17, 0xFF	; 255

000001b6 <D1>:
D1:	dec		r17				//student comment here
 1b6:	1a 95       	dec	r17
	brne	D1				//student comment here
 1b8:	f1 f7       	brne	.-4      	; 0x1b6 <D1>
	dec		r16				//student comment here
 1ba:	0a 95       	dec	r16
	brne	D0				//student comment here
 1bc:	d9 f7       	brne	.-10     	; 0x1b4 <D0>
	ret						//student comment here
 1be:	08 95       	ret

000001c0 <LCD_Write_Data>:

.global LCD_Write_Data
LCD_Write_Data:
	call	UART_Off		//student comment here
 1c0:	0e 94 04 01 	call	0x208	; 0x208 <UART_Off>
	ldi		r16,0xFF		//student comment here
 1c4:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		//student comment here
 1c6:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		//student comment here
 1c8:	00 91 62 03 	lds	r16, 0x0362	; 0x800362 <DATA>
	out		PORTD,r16		//student comment here
 1cc:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,6			//student comment here
 1ce:	06 e0       	ldi	r16, 0x06	; 6
	out		PORTB,r16		//student comment here
 1d0:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 1d2:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
	ldi		r16,0			//student comment here
 1d6:	00 e0       	ldi	r16, 0x00	; 0
	out		PORTB,r16		//student comment here
 1d8:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 1da:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
	call	UART_On			//student comment here
 1de:	0e 94 fe 00 	call	0x1fc	; 0x1fc <UART_On>
	ret						//student comment here
 1e2:	08 95       	ret

000001e4 <LCD_Read_Data>:

.global LCD_Read_Data
LCD_Read_Data:
	call	UART_Off		//student comment here
 1e4:	0e 94 04 01 	call	0x208	; 0x208 <UART_Off>
	ldi		r16,0x00		//student comment here
 1e8:	00 e0       	ldi	r16, 0x00	; 0
	out		DDRD,r16		//student comment here
 1ea:	0a b9       	out	0x0a, r16	; 10
	out		PORTB,4			//student comment here
 1ec:	45 b8       	out	0x05, r4	; 5
	in		r16,PORTD		//student comment here
 1ee:	0b b1       	in	r16, 0x0b	; 11
	sts		DATA,r16		//student comment here
 1f0:	00 93 62 03 	sts	0x0362, r16	; 0x800362 <DATA>
	out		PORTB,0			//student comment here
 1f4:	05 b8       	out	0x05, r0	; 5
	call	UART_On			//student comment here
 1f6:	0e 94 fe 00 	call	0x1fc	; 0x1fc <UART_On>
	ret						//student comment here
 1fa:	08 95       	ret

000001fc <UART_On>:

//Austin
.global UART_On
UART_On:
	ldi		r16,2				//student comment here
 1fc:	02 e0       	ldi	r16, 0x02	; 2
	out		DDRD,r16			//set data direction register to 00000010
 1fe:	0a b9       	out	0x0a, r16	; 10
	ldi		r16,24				
 200:	08 e1       	ldi	r16, 0x18	; 24
	sts		UCSR0B,r16			//Enables UART reciever and transmitter
 202:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret						
 206:	08 95       	ret

00000208 <UART_Off>:

.global UART_Off
UART_Off:
	ldi	r16,0					
 208:	00 e0       	ldi	r16, 0x00	; 0
	sts UCSR0B,r16				//disables reciever and transmitter
 20a:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret					
 20e:	08 95       	ret

00000210 <UART_Clear>:

.global UART_Clear
UART_Clear:
	lds		r16,UCSR0A			//recives register status from UART
 210:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r16,RXC0			//skips next line if data was recieved
 214:	07 ff       	sbrs	r16, 7
	ret							
 216:	08 95       	ret
	lds		r16,UDR0			//puts data into register, clears memory address
 218:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	rjmp	UART_Clear			//jumps back to begining
 21c:	f9 cf       	rjmp	.-14     	; 0x210 <UART_Clear>

0000021e <UART_Get>:

.global UART_Get
UART_Get:
	lds		r16,UCSR0A			//recives register status from UART
 21e:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r16,RXC0			//skips next line if data was recieved
 222:	07 ff       	sbrs	r16, 7
	rjmp	UART_Get			//jumps back if data was not recieved
 224:	fc cf       	rjmp	.-8      	; 0x21e <UART_Get>
	lds		r16,UDR0			//recives data 
 226:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	sts		ASCII,r16			//puts data into ASCII
 22a:	00 93 68 03 	sts	0x0368, r16	; 0x800368 <ASCII>
	ret							
 22e:	08 95       	ret

00000230 <UART_Poll>:

.global UART_Poll
UART_Poll:
	lds		r18,UCSR0A			//recives register status from UART
 230:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r18,RXC0			//skips next line if data was recieved
 234:	27 ff       	sbrs	r18, 7
	ret
 236:	08 95       	ret
	lds		r18,UDR0			//recives data 
 238:	20 91 c6 00 	lds	r18, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	sts		ASCII,r18			//puts data into ASCII
 23c:	20 93 68 03 	sts	0x0368, r18	; 0x800368 <ASCII>
	ret	
 240:	08 95       	ret

00000242 <UART_Put>:
	
.global UART_Put
UART_Put:
	lds		r17,UCSR0A			//recives register status from UART
 242:	10 91 c0 00 	lds	r17, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r17,UDRE0			//skips next line if UART not in transmitting mode
 246:	15 ff       	sbrs	r17, 5
	rjmp	UART_Put
 248:	fc cf       	rjmp	.-8      	; 0x242 <UART_Put>
	lds		r16,ASCII			//recieves put data
 24a:	00 91 68 03 	lds	r16, 0x0368	; 0x800368 <ASCII>
	sts		UDR0,r16			//outputs data
 24e:	00 93 c6 00 	sts	0x00C6, r16	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	ret	
 252:	08 95       	ret

00000254 <ADC_Get>:

//Mason
.global ADC_Get
ADC_Get:
	ldi		r16,0xC7			//Sets 0xC7 to register 16 to be loaded into address ADCSRA  
 254:	07 ec       	ldi	r16, 0xC7	; 199
	sts		ADCSRA,r16			//r16 is stored to address ADSRA for use in loop
 256:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>

0000025a <A2V1>:
A2V1:
	lds		r16,ADCSRA			//loads value stored in ADSRA to r16 a reset of the value
 25a:	00 91 7a 00 	lds	r16, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
	sbrc	r16,ADSC			//If the bit in r16 is cleared skips the next instruction, this will end the loop
 25e:	06 fd       	sbrc	r16, 6
	rjmp 	A2V1				//Jumps back to A2V1 to create loop 
 260:	fc cf       	rjmp	.-8      	; 0x25a <A2V1>
	lds		r16,ADCL			//The low value of the ADC port is stored in r16
 262:	00 91 78 00 	lds	r16, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
	sts		LADC,r16			//Then the value of ADCL is loaded into a global address to be used in C program
 266:	00 93 70 03 	sts	0x0370, r16	; 0x800370 <LADC>
	lds		r16,ADCH			//The high value of the ADC port is stored in r16
 26a:	00 91 79 00 	lds	r16, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
	sts		HADC,r16			//Then stored to the global address HADC to be used in C program
 26e:	00 93 63 03 	sts	0x0363, r16	; 0x800363 <HADC>
	ret							//Returns to the section where call was made
 272:	08 95       	ret

00000274 <EEPROM_Write>:

.global EEPROM_Write
EEPROM_Write:      
	sbic    EECR,EEPE
 274:	f9 99       	sbic	0x1f, 1	; 31
	rjmp    EEPROM_Write		; Wait for completion of previous write
 276:	fe cf       	rjmp	.-4      	; 0x274 <EEPROM_Write>
	lds		r18,EELOCH			; Set up address (r18:r17) in address register
 278:	20 91 6e 03 	lds	r18, 0x036E	; 0x80036e <EELOCH>
	lds		r17,EELOCL 
 27c:	10 91 66 03 	lds	r17, 0x0366	; 0x800366 <EELOCL>
	ldi		r16,'F'				; Set up data in r16    
 280:	06 e4       	ldi	r16, 0x46	; 70
	out     EEARH, r18      
 282:	22 bd       	out	0x22, r18	; 34
	out     EEARL, r17			      
 284:	11 bd       	out	0x21, r17	; 33
	out     EEDR,r16			; Write data (r16) to Data Register  
 286:	00 bd       	out	0x20, r16	; 32
	sbi     EECR,EEMPE			; Write logical one to EEMPE
 288:	fa 9a       	sbi	0x1f, 2	; 31
	sbi     EECR,EEPE			; Start eeprom write by setting EEPE
 28a:	f9 9a       	sbi	0x1f, 1	; 31
	ret 
 28c:	08 95       	ret

0000028e <EEPROM_Read>:

.global EEPROM_Read
EEPROM_Read:					    
	sbic    EECR,EEPE    
 28e:	f9 99       	sbic	0x1f, 1	; 31
	rjmp    EEPROM_Read			; Wait for completion of previous write
 290:	fe cf       	rjmp	.-4      	; 0x28e <EEPROM_Read>
	lds		r18,EELOCH			; Set up address (r18:r17) in EEPROM address register
 292:	20 91 6e 03 	lds	r18, 0x036E	; 0x80036e <EELOCH>
	lds		r17,EELOCL
 296:	10 91 66 03 	lds	r17, 0x0366	; 0x800366 <EELOCL>
	ldi		r16,0x00   
 29a:	00 e0       	ldi	r16, 0x00	; 0
	out     EEARH, r18   
 29c:	22 bd       	out	0x22, r18	; 34
	out     EEARL, r17		   
 29e:	11 bd       	out	0x21, r17	; 33
	sbi     EECR,EERE			; Start eeprom read by writing EERE
 2a0:	f8 9a       	sbi	0x1f, 0	; 31
	in      r16,EEDR			; Read data from Data Register
 2a2:	00 b5       	in	r16, 0x20	; 32
	sts		ASCII,r16  
 2a4:	00 93 68 03 	sts	0x0368, r16	; 0x800368 <ASCII>
	ret
 2a8:	08 95       	ret

000002aa <SETC>:

.global SETC
SETC: 
	lds		r16, UCSR0C
 2aa:	00 91 c2 00 	lds	r16, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
	lds		r17, USARTDATA
 2ae:	10 91 60 03 	lds	r17, 0x0360	; 0x800360 <__data_end>
	or		r16, r17
 2b2:	01 2b       	or	r16, r17
	sts		UCSR0C, r16
 2b4:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
	ret		
 2b8:	08 95       	ret

000002ba <CLEARC>:

.global CLEARC
CLEARC: 
	lds		r16, UCSR0C
 2ba:	00 91 c2 00 	lds	r16, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
	ldi		r17, 0xFF
 2be:	1f ef       	ldi	r17, 0xFF	; 255
	lds		r18, USARTDATA
 2c0:	20 91 60 03 	lds	r18, 0x0360	; 0x800360 <__data_end>
	sub		r17, r18
 2c4:	12 1b       	sub	r17, r18
	and		r16, r17
 2c6:	01 23       	and	r16, r17
	sts		UCSR0C, r16
 2c8:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
	ret
 2cc:	08 95       	ret

000002ce <SETB>:

.global SETB
SETB: 
	lds		r16, UCSR0B
 2ce:	00 91 c1 00 	lds	r16, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ldi		r17, 0xFF
 2d2:	1f ef       	ldi	r17, 0xFF	; 255
	lds		r18, USARTDATA
 2d4:	20 91 60 03 	lds	r18, 0x0360	; 0x800360 <__data_end>
	sub		r17, r18
 2d8:	12 1b       	sub	r17, r18
	and		r16, r17
 2da:	01 23       	and	r16, r17
	sts		UCSR0B, r16
 2dc:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret
 2e0:	08 95       	ret

000002e2 <CLEARB>:
	
.global CLEARB
CLEARB:
	lds		r16, UCSR0B
 2e2:	00 91 c1 00 	lds	r16, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	lds		r17, USARTDATA
 2e6:	10 91 60 03 	lds	r17, 0x0360	; 0x800360 <__data_end>
	or		r16, r17
 2ea:	01 2b       	or	r16, r17
	sts		UCSR0B, r16
 2ec:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret
 2f0:	08 95       	ret

000002f2 <SETBAUD>:

.global SETBAUD
SETBAUD:
	lds		r16, BAUDL
 2f2:	00 91 73 03 	lds	r16, 0x0373	; 0x800373 <BAUDL>
	lds		r17, BAUDH
 2f6:	10 91 64 03 	lds	r17, 0x0364	; 0x800364 <BAUDH>
	sts		UBRR0L,r16
 2fa:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	sts		UBRR0H,r17
 2fe:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
	ret
 302:	08 95       	ret

00000304 <UART_Puts>:
char HADC;						//shared ADC variable with Assembly
char LADC;						//shared ADC variable with Assembly
char temp[5];					//string buffer for ADC output

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
 304:	cf 93       	push	r28
 306:	df 93       	push	r29
 308:	ec 01       	movw	r28, r24
	while (*str)
 30a:	98 81       	ld	r25, Y
 30c:	99 23       	and	r25, r25
 30e:	41 f0       	breq	.+16     	; 0x320 <UART_Puts+0x1c>
 310:	21 96       	adiw	r28, 0x01	; 1
	{
		ASCII = *str++;
 312:	90 93 68 03 	sts	0x0368, r25	; 0x800368 <ASCII>
		UART_Put();
 316:	0e 94 21 01 	call	0x242	; 0x242 <UART_Put>
char LADC;						//shared ADC variable with Assembly
char temp[5];					//string buffer for ADC output

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
	while (*str)
 31a:	99 91       	ld	r25, Y+
 31c:	91 11       	cpse	r25, r1
 31e:	f9 cf       	rjmp	.-14     	; 0x312 <UART_Puts+0xe>
	{
		ASCII = *str++;
		UART_Put();
	}
}
 320:	df 91       	pop	r29
 322:	cf 91       	pop	r28
 324:	08 95       	ret

00000326 <LCD_Puts>:

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
 326:	cf 93       	push	r28
 328:	df 93       	push	r29
 32a:	ec 01       	movw	r28, r24
	while (*str)
 32c:	98 81       	ld	r25, Y
 32e:	99 23       	and	r25, r25
 330:	41 f0       	breq	.+16     	; 0x342 <LCD_Puts+0x1c>
 332:	21 96       	adiw	r28, 0x01	; 1
	{
		DATA = *str++;
 334:	90 93 62 03 	sts	0x0362, r25	; 0x800362 <DATA>
		LCD_Write_Data();
 338:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <LCD_Write_Data>
	}
}

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
	while (*str)
 33c:	99 91       	ld	r25, Y+
 33e:	91 11       	cpse	r25, r1
 340:	f9 cf       	rjmp	.-14     	; 0x334 <LCD_Puts+0xe>
	{
		DATA = *str++;
		LCD_Write_Data();
	}
}
 342:	df 91       	pop	r29
 344:	cf 91       	pop	r28
 346:	08 95       	ret

00000348 <Banner>:

void Banner(void)				//Display Tiny OS Banner on Terminal
{
	UART_Puts(MS1);
 348:	82 e4       	ldi	r24, 0x42	; 66
 34a:	93 e0       	ldi	r25, 0x03	; 3
 34c:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
	UART_Puts(MS2);
 350:	8b e0       	ldi	r24, 0x0B	; 11
 352:	93 e0       	ldi	r25, 0x03	; 3
 354:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
	UART_Puts(MS4);
 358:	86 ed       	ldi	r24, 0xD6	; 214
 35a:	92 e0       	ldi	r25, 0x02	; 2
 35c:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
 360:	08 95       	ret

00000362 <HELP>:
}

void HELP(void)						//Display available Tiny OS Commands on Terminal
{
	UART_Puts(MS3);
 362:	80 ee       	ldi	r24, 0xE0	; 224
 364:	92 e0       	ldi	r25, 0x02	; 2
 366:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
 36a:	08 95       	ret

0000036c <LCD>:
}

void LCD(void)						//Lite LCD demo
{	
 36c:	ff 92       	push	r15
 36e:	0f 93       	push	r16
 370:	1f 93       	push	r17
 372:	cf 93       	push	r28
 374:	df 93       	push	r29
	LCD_Write_Command();
 376:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x08;					//Turns display and cursor off
 37a:	88 e0       	ldi	r24, 0x08	; 8
 37c:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <DATA>
	LCD_Write_Command();
 380:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x02;					//Returns home
 384:	82 e0       	ldi	r24, 0x02	; 2
 386:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <DATA>
	LCD_Write_Command();
 38a:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x06;					//Shifts Cursor to the right
 38e:	86 e0       	ldi	r24, 0x06	; 6
 390:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <DATA>
	LCD_Write_Command();
 394:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x0f;					//Display on cursor blinking
 398:	8f e0       	ldi	r24, 0x0F	; 15
 39a:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <DATA>
	LCD_Write_Command();
 39e:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x0c;					//Display on cursor off
 3a2:	8c e0       	ldi	r24, 0x0C	; 12
 3a4:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <DATA>
	LCD_Write_Command();
 3a8:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	
	LCD_Puts(output);				//Puts the output sting onto the LCD
 3ac:	80 e0       	ldi	r24, 0x00	; 0
 3ae:	91 e0       	ldi	r25, 0x01	; 1
 3b0:	0e 94 93 01 	call	0x326	; 0x326 <LCD_Puts>
 3b4:	00 e1       	ldi	r16, 0x10	; 16
 3b6:	10 e0       	ldi	r17, 0x00	; 0

	for (int i = 0; i < 16; i++){	//Loop to shift a total of 16 
		DATA = 0x1c;				//Shifts data to the right 1 
 3b8:	0f 2e       	mov	r0, r31
 3ba:	fc e1       	ldi	r31, 0x1C	; 28
 3bc:	ff 2e       	mov	r15, r31
 3be:	f0 2d       	mov	r31, r0
 3c0:	f0 92 62 03 	sts	0x0362, r15	; 0x800362 <DATA>
		ASCII = '\0';
 3c4:	10 92 68 03 	sts	0x0368, r1	; 0x800368 <ASCII>
 3c8:	c2 e3       	ldi	r28, 0x32	; 50
 3ca:	d0 e0       	ldi	r29, 0x00	; 0
		for (int j = 0; j < 50; j++){
			UART_Poll();
 3cc:	0e 94 18 01 	call	0x230	; 0x230 <UART_Poll>
			LCD_Delay();	
 3d0:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
 3d4:	21 97       	sbiw	r28, 0x01	; 1
	LCD_Puts(output);				//Puts the output sting onto the LCD

	for (int i = 0; i < 16; i++){	//Loop to shift a total of 16 
		DATA = 0x1c;				//Shifts data to the right 1 
		ASCII = '\0';
		for (int j = 0; j < 50; j++){
 3d6:	d1 f7       	brne	.-12     	; 0x3cc <LCD+0x60>
			UART_Poll();
			LCD_Delay();	
		}
		if (ASCII != '\0')
 3d8:	80 91 68 03 	lds	r24, 0x0368	; 0x800368 <ASCII>
 3dc:	81 11       	cpse	r24, r1
 3de:	05 c0       	rjmp	.+10     	; 0x3ea <LCD+0x7e>
			break;
			
		LCD_Write_Command();		//Writes after shift
 3e0:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
 3e4:	01 50       	subi	r16, 0x01	; 1
 3e6:	11 09       	sbc	r17, r1
	DATA = 0x0c;					//Display on cursor off
	LCD_Write_Command();
	
	LCD_Puts(output);				//Puts the output sting onto the LCD

	for (int i = 0; i < 16; i++){	//Loop to shift a total of 16 
 3e8:	59 f7       	brne	.-42     	; 0x3c0 <LCD+0x54>
		if (ASCII != '\0')
			break;
			
		LCD_Write_Command();		//Writes after shift
	} 
}
 3ea:	df 91       	pop	r29
 3ec:	cf 91       	pop	r28
 3ee:	1f 91       	pop	r17
 3f0:	0f 91       	pop	r16
 3f2:	ff 90       	pop	r15
 3f4:	08 95       	ret

000003f6 <Temperature_ADC>:

void Temperature_ADC(void)						//Lite Demo of the Analog to Digital Converter
{
 3f6:	3f 92       	push	r3
 3f8:	4f 92       	push	r4
 3fa:	5f 92       	push	r5
 3fc:	6f 92       	push	r6
 3fe:	7f 92       	push	r7
 400:	8f 92       	push	r8
 402:	9f 92       	push	r9
 404:	af 92       	push	r10
 406:	bf 92       	push	r11
 408:	cf 92       	push	r12
 40a:	df 92       	push	r13
 40c:	ef 92       	push	r14
 40e:	ff 92       	push	r15
 410:	0f 93       	push	r16
 412:	1f 93       	push	r17
 414:	cf 93       	push	r28
 416:	df 93       	push	r29
	double r, t;									//Values used for calculation
	int rn = 10000;									//Value used for calculation
	ASCII = '\0';
 418:	10 92 68 03 	sts	0x0368, r1	; 0x800368 <ASCII>
	
while(ASCII == '\0' )
	{
	temp[0x2]='.';									//Reserves index 2 in char array for '.'
 41c:	c9 e6       	ldi	r28, 0x69	; 105
 41e:	d3 e0       	ldi	r29, 0x03	; 3
 420:	0f 2e       	mov	r0, r31
 422:	fe e2       	ldi	r31, 0x2E	; 46
 424:	3f 2e       	mov	r3, r31
 426:	f0 2d       	mov	r31, r0
	temp[0x4]=' ';									//Reserves index 4 in char array for a space
 428:	68 94       	set
 42a:	ee 24       	eor	r14, r14
 42c:	e5 f8       	bld	r14, 5

    int i = t*10;									//creates an integer i from the the float. Multiplies by 10 to move over decimal point
	int j = t;										//explicit cast of float to int to
	
	temp[0x0] = i / 100 + 48;						//Calculates the first digit in the 2 digits left of the "."
	temp[0x1] = j % 10 + 48;						//Calculates the second digit in the 2 digits left of the "."
 42e:	0f 2e       	mov	r0, r31
 430:	fa e0       	ldi	r31, 0x0A	; 10
 432:	cf 2e       	mov	r12, r31
 434:	d1 2c       	mov	r13, r1
 436:	f0 2d       	mov	r31, r0
	UART_Puts(MS7);									//Puts MS7 which is ºF

	ASCII = '\0';
	UART_Poll();
	
	temp[0x0] = 48;									//sets the first digit to 0 to clear
 438:	0f 2e       	mov	r0, r31
 43a:	f0 e3       	ldi	r31, 0x30	; 48
 43c:	ff 2e       	mov	r15, r31
 43e:	f0 2d       	mov	r31, r0
	int rn = 10000;									//Value used for calculation
	ASCII = '\0';
	
while(ASCII == '\0' )
	{
	temp[0x2]='.';									//Reserves index 2 in char array for '.'
 440:	3a 82       	std	Y+2, r3	; 0x02
	temp[0x4]=' ';									//Reserves index 4 in char array for a space
 442:	ec 82       	std	Y+4, r14	; 0x04
	temp[0x5]= 0;									//Does nothing for space 5
 444:	1d 82       	std	Y+5, r1	; 0x05
	
	ADC_Get();										//Gets the ADC value from assembly file
 446:	0e 94 2a 01 	call	0x254	; 0x254 <ADC_Get>
	Acc = (((int)HADC)*0x100+(int)(LADC));			//Calculates given value being read from the circuit into a int
 44a:	60 91 63 03 	lds	r22, 0x0363	; 0x800363 <HADC>
 44e:	70 e0       	ldi	r23, 0x00	; 0
 450:	76 2f       	mov	r23, r22
 452:	66 27       	eor	r22, r22
 454:	80 91 70 03 	lds	r24, 0x0370	; 0x800370 <LADC>
 458:	68 0f       	add	r22, r24
 45a:	71 1d       	adc	r23, r1
 45c:	70 93 72 03 	sts	0x0372, r23	; 0x800372 <Acc+0x1>
 460:	60 93 71 03 	sts	0x0371, r22	; 0x800371 <Acc>
	r = (10000.0 * Acc) / (1024.0 - Acc);			//Equation 1 from given sheet
 464:	07 2e       	mov	r0, r23
 466:	00 0c       	add	r0, r0
 468:	88 0b       	sbc	r24, r24
 46a:	99 0b       	sbc	r25, r25
 46c:	0e 94 cb 05 	call	0xb96	; 0xb96 <__floatsisf>
 470:	4b 01       	movw	r8, r22
 472:	5c 01       	movw	r10, r24
	t = (3950*298.15)/(298.15*log(r/rn) + 3950);	//Equation 2 from given sheet
 474:	20 e0       	ldi	r18, 0x00	; 0
 476:	30 e4       	ldi	r19, 0x40	; 64
 478:	4c e1       	ldi	r20, 0x1C	; 28
 47a:	56 e4       	ldi	r21, 0x46	; 70
 47c:	0e 94 a7 06 	call	0xd4e	; 0xd4e <__mulsf3>
 480:	2b 01       	movw	r4, r22
 482:	3c 01       	movw	r6, r24
 484:	a5 01       	movw	r20, r10
 486:	94 01       	movw	r18, r8
 488:	60 e0       	ldi	r22, 0x00	; 0
 48a:	70 e0       	ldi	r23, 0x00	; 0
 48c:	80 e8       	ldi	r24, 0x80	; 128
 48e:	94 e4       	ldi	r25, 0x44	; 68
 490:	0e 94 b4 04 	call	0x968	; 0x968 <__subsf3>
 494:	9b 01       	movw	r18, r22
 496:	ac 01       	movw	r20, r24
 498:	c3 01       	movw	r24, r6
 49a:	b2 01       	movw	r22, r4
 49c:	0e 94 21 05 	call	0xa42	; 0xa42 <__divsf3>
 4a0:	20 e0       	ldi	r18, 0x00	; 0
 4a2:	30 e4       	ldi	r19, 0x40	; 64
 4a4:	4c e1       	ldi	r20, 0x1C	; 28
 4a6:	56 e4       	ldi	r21, 0x46	; 70
 4a8:	0e 94 21 05 	call	0xa42	; 0xa42 <__divsf3>
 4ac:	0e 94 5f 06 	call	0xcbe	; 0xcbe <log>
 4b0:	23 e3       	ldi	r18, 0x33	; 51
 4b2:	33 e1       	ldi	r19, 0x13	; 19
 4b4:	45 e9       	ldi	r20, 0x95	; 149
 4b6:	53 e4       	ldi	r21, 0x43	; 67
 4b8:	0e 94 a7 06 	call	0xd4e	; 0xd4e <__mulsf3>
 4bc:	20 e0       	ldi	r18, 0x00	; 0
 4be:	30 ee       	ldi	r19, 0xE0	; 224
 4c0:	46 e7       	ldi	r20, 0x76	; 118
 4c2:	55 e4       	ldi	r21, 0x45	; 69
 4c4:	0e 94 b5 04 	call	0x96a	; 0x96a <__addsf3>
 4c8:	9b 01       	movw	r18, r22
 4ca:	ac 01       	movw	r20, r24
 4cc:	64 ee       	ldi	r22, 0xE4	; 228
 4ce:	72 ec       	ldi	r23, 0xC2	; 194
 4d0:	8f e8       	ldi	r24, 0x8F	; 143
 4d2:	99 e4       	ldi	r25, 0x49	; 73
 4d4:	0e 94 21 05 	call	0xa42	; 0xa42 <__divsf3>
	t = t - 273.15;									//Convert to C from K
 4d8:	23 e3       	ldi	r18, 0x33	; 51
 4da:	33 e9       	ldi	r19, 0x93	; 147
 4dc:	48 e8       	ldi	r20, 0x88	; 136
 4de:	53 e4       	ldi	r21, 0x43	; 67
 4e0:	0e 94 b4 04 	call	0x968	; 0x968 <__subsf3>
	t = t*(9/5) + 32;								//Convert to F from C
 4e4:	20 e0       	ldi	r18, 0x00	; 0
 4e6:	30 e0       	ldi	r19, 0x00	; 0
 4e8:	40 e0       	ldi	r20, 0x00	; 0
 4ea:	52 e4       	ldi	r21, 0x42	; 66
 4ec:	0e 94 b5 04 	call	0x96a	; 0x96a <__addsf3>
 4f0:	4b 01       	movw	r8, r22
 4f2:	5c 01       	movw	r10, r24

    int i = t*10;									//creates an integer i from the the float. Multiplies by 10 to move over decimal point
 4f4:	20 e0       	ldi	r18, 0x00	; 0
 4f6:	30 e0       	ldi	r19, 0x00	; 0
 4f8:	40 e2       	ldi	r20, 0x20	; 32
 4fa:	51 e4       	ldi	r21, 0x41	; 65
 4fc:	0e 94 a7 06 	call	0xd4e	; 0xd4e <__mulsf3>
 500:	0e 94 93 05 	call	0xb26	; 0xb26 <__fixsfsi>
 504:	8b 01       	movw	r16, r22
	int j = t;										//explicit cast of float to int to
	
	temp[0x0] = i / 100 + 48;						//Calculates the first digit in the 2 digits left of the "."
 506:	cb 01       	movw	r24, r22
 508:	64 e6       	ldi	r22, 0x64	; 100
 50a:	70 e0       	ldi	r23, 0x00	; 0
 50c:	0e 94 49 07 	call	0xe92	; 0xe92 <__divmodhi4>
 510:	60 5d       	subi	r22, 0xD0	; 208
 512:	68 83       	st	Y, r22
	temp[0x1] = j % 10 + 48;						//Calculates the second digit in the 2 digits left of the "."
 514:	c5 01       	movw	r24, r10
 516:	b4 01       	movw	r22, r8
 518:	0e 94 93 05 	call	0xb26	; 0xb26 <__fixsfsi>
 51c:	cb 01       	movw	r24, r22
 51e:	b6 01       	movw	r22, r12
 520:	0e 94 49 07 	call	0xe92	; 0xe92 <__divmodhi4>
 524:	80 5d       	subi	r24, 0xD0	; 208
 526:	89 83       	std	Y+1, r24	; 0x01
	temp[0x3] = i % 10 + 48;						//Calculates the values for the decimal
 528:	c8 01       	movw	r24, r16
 52a:	b6 01       	movw	r22, r12
 52c:	0e 94 49 07 	call	0xe92	; 0xe92 <__divmodhi4>
 530:	80 5d       	subi	r24, 0xD0	; 208
 532:	8b 83       	std	Y+3, r24	; 0x03

	UART_Puts(temp);								//Puts the full char array of 'temp'
 534:	ce 01       	movw	r24, r28
 536:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
	UART_Puts(MS7);									//Puts MS7 which is ºF
 53a:	84 eb       	ldi	r24, 0xB4	; 180
 53c:	92 e0       	ldi	r25, 0x02	; 2
 53e:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>

	ASCII = '\0';
 542:	10 92 68 03 	sts	0x0368, r1	; 0x800368 <ASCII>
	UART_Poll();
 546:	0e 94 18 01 	call	0x230	; 0x230 <UART_Poll>
	
	temp[0x0] = 48;									//sets the first digit to 0 to clear
 54a:	f8 82       	st	Y, r15
	temp[0x1] = 48;									//sets the second digit to 0 to clear
 54c:	f9 82       	std	Y+1, r15	; 0x01
	temp[0x3] = 48;									//sets the decimal digit to 0 to clear
 54e:	fb 82       	std	Y+3, r15	; 0x03
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 550:	2f e3       	ldi	r18, 0x3F	; 63
 552:	82 e4       	ldi	r24, 0x42	; 66
 554:	9f e0       	ldi	r25, 0x0F	; 15
 556:	21 50       	subi	r18, 0x01	; 1
 558:	80 40       	sbci	r24, 0x00	; 0
 55a:	90 40       	sbci	r25, 0x00	; 0
 55c:	e1 f7       	brne	.-8      	; 0x556 <__LOCK_REGION_LENGTH__+0x156>
 55e:	00 c0       	rjmp	.+0      	; 0x560 <__LOCK_REGION_LENGTH__+0x160>
 560:	00 00       	nop
{
	double r, t;									//Values used for calculation
	int rn = 10000;									//Value used for calculation
	ASCII = '\0';
	
while(ASCII == '\0' )
 562:	80 91 68 03 	lds	r24, 0x0368	; 0x800368 <ASCII>
 566:	88 23       	and	r24, r24
 568:	09 f4       	brne	.+2      	; 0x56c <__LOCK_REGION_LENGTH__+0x16c>
 56a:	6a cf       	rjmp	.-300    	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
	temp[0x1] = 48;									//sets the second digit to 0 to clear
	temp[0x3] = 48;									//sets the decimal digit to 0 to clear
		
	_delay_ms(5000);
	}
	ASCII = '\0';	
 56c:	10 92 68 03 	sts	0x0368, r1	; 0x800368 <ASCII>
}
 570:	df 91       	pop	r29
 572:	cf 91       	pop	r28
 574:	1f 91       	pop	r17
 576:	0f 91       	pop	r16
 578:	ff 90       	pop	r15
 57a:	ef 90       	pop	r14
 57c:	df 90       	pop	r13
 57e:	cf 90       	pop	r12
 580:	bf 90       	pop	r11
 582:	af 90       	pop	r10
 584:	9f 90       	pop	r9
 586:	8f 90       	pop	r8
 588:	7f 90       	pop	r7
 58a:	6f 90       	pop	r6
 58c:	5f 90       	pop	r5
 58e:	4f 90       	pop	r4
 590:	3f 90       	pop	r3
 592:	08 95       	ret

00000594 <EEPROM>:

void EEPROM(void)
{
 594:	ef 92       	push	r14
 596:	ff 92       	push	r15
 598:	0f 93       	push	r16
 59a:	1f 93       	push	r17
 59c:	cf 93       	push	r28
 59e:	df 93       	push	r29
 5a0:	cd b7       	in	r28, 0x3d	; 61
 5a2:	de b7       	in	r29, 0x3e	; 62
 5a4:	27 97       	sbiw	r28, 0x07	; 7
 5a6:	0f b6       	in	r0, 0x3f	; 63
 5a8:	f8 94       	cli
 5aa:	de bf       	out	0x3e, r29	; 62
 5ac:	0f be       	out	0x3f, r0	; 63
 5ae:	cd bf       	out	0x3d, r28	; 61
	char eeGet[] = "0x####";
 5b0:	87 e0       	ldi	r24, 0x07	; 7
 5b2:	e9 e8       	ldi	r30, 0x89	; 137
 5b4:	f1 e0       	ldi	r31, 0x01	; 1
 5b6:	de 01       	movw	r26, r28
 5b8:	11 96       	adiw	r26, 0x01	; 1
 5ba:	01 90       	ld	r0, Z+
 5bc:	0d 92       	st	X+, r0
 5be:	8a 95       	dec	r24
 5c0:	e1 f7       	brne	.-8      	; 0x5ba <EEPROM+0x26>
	UART_Puts("\r\nEEPROM Write and Read.");
 5c2:	88 e4       	ldi	r24, 0x48	; 72
 5c4:	91 e0       	ldi	r25, 0x01	; 1
 5c6:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
	during run-time via the command line and the same byte of data can be read back and verified after the power to
	the Xplained Mini board has been cycled. Ask the user to enter a valid EEPROM address and an
	8-bit data value. Utilize the following two given Assembly based drivers to communicate with the EEPROM. You
	may modify the EEPROM drivers as needed. User must be able to always return to command line.
	*/
	UART_Puts("\r\ninput memory location in this format: 0x####");
 5ca:	81 e6       	ldi	r24, 0x61	; 97
 5cc:	91 e0       	ldi	r25, 0x01	; 1
 5ce:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
 5d2:	8e 01       	movw	r16, r28
 5d4:	0f 5f       	subi	r16, 0xFF	; 255
 5d6:	1f 4f       	sbci	r17, 0xFF	; 255
 5d8:	7e 01       	movw	r14, r28
 5da:	87 e0       	ldi	r24, 0x07	; 7
 5dc:	e8 0e       	add	r14, r24
 5de:	f1 1c       	adc	r15, r1

	for (int i = 0; i < 6; i++){
		ASCII = '\0';
 5e0:	10 92 68 03 	sts	0x0368, r1	; 0x800368 <ASCII>
		while (ASCII == '\0'){
			UART_Get();
 5e4:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>
	*/
	UART_Puts("\r\ninput memory location in this format: 0x####");

	for (int i = 0; i < 6; i++){
		ASCII = '\0';
		while (ASCII == '\0'){
 5e8:	80 91 68 03 	lds	r24, 0x0368	; 0x800368 <ASCII>
 5ec:	88 23       	and	r24, r24
 5ee:	d1 f3       	breq	.-12     	; 0x5e4 <EEPROM+0x50>
			UART_Get();
			}
		eeGet[i] = ASCII;
 5f0:	f8 01       	movw	r30, r16
 5f2:	81 93       	st	Z+, r24
 5f4:	8f 01       	movw	r16, r30
		UART_Puts(eeGet[i]);
 5f6:	90 e0       	ldi	r25, 0x00	; 0
 5f8:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
	8-bit data value. Utilize the following two given Assembly based drivers to communicate with the EEPROM. You
	may modify the EEPROM drivers as needed. User must be able to always return to command line.
	*/
	UART_Puts("\r\ninput memory location in this format: 0x####");

	for (int i = 0; i < 6; i++){
 5fc:	0e 15       	cp	r16, r14
 5fe:	1f 05       	cpc	r17, r15
 600:	79 f7       	brne	.-34     	; 0x5e0 <EEPROM+0x4c>
			UART_Get();
			}
		eeGet[i] = ASCII;
		UART_Puts(eeGet[i]);
	}
	EELOCH = (eeGet[2] - 48) + (eeGet[3] - 48);
 602:	2b 81       	ldd	r18, Y+3	; 0x03
 604:	8c 81       	ldd	r24, Y+4	; 0x04
 606:	90 e0       	ldi	r25, 0x00	; 0
 608:	82 0f       	add	r24, r18
 60a:	91 1d       	adc	r25, r1
 60c:	80 56       	subi	r24, 0x60	; 96
 60e:	91 09       	sbc	r25, r1
 610:	90 93 6f 03 	sts	0x036F, r25	; 0x80036f <EELOCH+0x1>
 614:	80 93 6e 03 	sts	0x036E, r24	; 0x80036e <EELOCH>
	EELOCL = (eeGet[4] - 48) + (eeGet[5] - 48);
 618:	2d 81       	ldd	r18, Y+5	; 0x05
 61a:	8e 81       	ldd	r24, Y+6	; 0x06
 61c:	90 e0       	ldi	r25, 0x00	; 0
 61e:	82 0f       	add	r24, r18
 620:	91 1d       	adc	r25, r1
 622:	80 56       	subi	r24, 0x60	; 96
 624:	91 09       	sbc	r25, r1
 626:	90 93 67 03 	sts	0x0367, r25	; 0x800367 <EELOCL+0x1>
 62a:	80 93 66 03 	sts	0x0366, r24	; 0x800366 <EELOCL>
	UART_Puts("\r\n");
 62e:	86 eb       	ldi	r24, 0xB6	; 182
 630:	91 e0       	ldi	r25, 0x01	; 1
 632:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
	EEPROM_Write();
 636:	0e 94 3a 01 	call	0x274	; 0x274 <EEPROM_Write>
	UART_Puts("\r\n");
 63a:	86 eb       	ldi	r24, 0xB6	; 182
 63c:	91 e0       	ldi	r25, 0x01	; 1
 63e:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
	EEPROM_Read();
 642:	0e 94 47 01 	call	0x28e	; 0x28e <EEPROM_Read>
	UART_Put();
 646:	0e 94 21 01 	call	0x242	; 0x242 <UART_Put>
	UART_Puts("\r\n");
 64a:	86 eb       	ldi	r24, 0xB6	; 182
 64c:	91 e0       	ldi	r25, 0x01	; 1
 64e:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
}
 652:	27 96       	adiw	r28, 0x07	; 7
 654:	0f b6       	in	r0, 0x3f	; 63
 656:	f8 94       	cli
 658:	de bf       	out	0x3e, r29	; 62
 65a:	0f be       	out	0x3f, r0	; 63
 65c:	cd bf       	out	0x3d, r28	; 61
 65e:	df 91       	pop	r29
 660:	cf 91       	pop	r28
 662:	1f 91       	pop	r17
 664:	0f 91       	pop	r16
 666:	ff 90       	pop	r15
 668:	ef 90       	pop	r14
 66a:	08 95       	ret

0000066c <BAUD>:

void BAUD(void)
{
	UART_Puts("\r\nBaud rater\n(1)9600\r\n(2)2400\r\n(3)1200\r\n");
 66c:	80 e9       	ldi	r24, 0x90	; 144
 66e:	91 e0       	ldi	r25, 0x01	; 1
 670:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
	ASCII = '\0';
 674:	10 92 68 03 	sts	0x0368, r1	; 0x800368 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 678:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>

void BAUD(void)
{
	UART_Puts("\r\nBaud rater\n(1)9600\r\n(2)2400\r\n(3)1200\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 67c:	80 91 68 03 	lds	r24, 0x0368	; 0x800368 <ASCII>
 680:	88 23       	and	r24, r24
 682:	d1 f3       	breq	.-12     	; 0x678 <BAUD+0xc>
	{
		UART_Get();
	}
	switch (ASCII)
 684:	82 33       	cpi	r24, 0x32	; 50
 686:	89 f0       	breq	.+34     	; 0x6aa <BAUD+0x3e>
 688:	83 33       	cpi	r24, 0x33	; 51
 68a:	f1 f0       	breq	.+60     	; 0x6c8 <BAUD+0x5c>
 68c:	81 33       	cpi	r24, 0x31	; 49
 68e:	59 f5       	brne	.+86     	; 0x6e6 <BAUD+0x7a>
	{
		case '1':
		BAUDH = 0;
 690:	10 92 65 03 	sts	0x0365, r1	; 0x800365 <BAUDH+0x1>
 694:	10 92 64 03 	sts	0x0364, r1	; 0x800364 <BAUDH>
		BAUDL = 103;
 698:	87 e6       	ldi	r24, 0x67	; 103
 69a:	90 e0       	ldi	r25, 0x00	; 0
 69c:	90 93 74 03 	sts	0x0374, r25	; 0x800374 <BAUDL+0x1>
 6a0:	80 93 73 03 	sts	0x0373, r24	; 0x800373 <BAUDL>
		SETBAUD();
 6a4:	0e 94 79 01 	call	0x2f2	; 0x2f2 <SETBAUD>
		break;
 6a8:	08 95       	ret
		case '2':
		BAUDH = 1;
 6aa:	81 e0       	ldi	r24, 0x01	; 1
 6ac:	90 e0       	ldi	r25, 0x00	; 0
 6ae:	90 93 65 03 	sts	0x0365, r25	; 0x800365 <BAUDH+0x1>
 6b2:	80 93 64 03 	sts	0x0364, r24	; 0x800364 <BAUDH>
		BAUDL = 159;
 6b6:	8f e9       	ldi	r24, 0x9F	; 159
 6b8:	90 e0       	ldi	r25, 0x00	; 0
 6ba:	90 93 74 03 	sts	0x0374, r25	; 0x800374 <BAUDL+0x1>
 6be:	80 93 73 03 	sts	0x0373, r24	; 0x800373 <BAUDL>
		SETBAUD();
 6c2:	0e 94 79 01 	call	0x2f2	; 0x2f2 <SETBAUD>
		break;
 6c6:	08 95       	ret
		case '3':
		BAUDH = 3;
 6c8:	83 e0       	ldi	r24, 0x03	; 3
 6ca:	90 e0       	ldi	r25, 0x00	; 0
 6cc:	90 93 65 03 	sts	0x0365, r25	; 0x800365 <BAUDH+0x1>
 6d0:	80 93 64 03 	sts	0x0364, r24	; 0x800364 <BAUDH>
		BAUDL = 63;
 6d4:	8f e3       	ldi	r24, 0x3F	; 63
 6d6:	90 e0       	ldi	r25, 0x00	; 0
 6d8:	90 93 74 03 	sts	0x0374, r25	; 0x800374 <BAUDL+0x1>
 6dc:	80 93 73 03 	sts	0x0373, r24	; 0x800373 <BAUDL>
		SETBAUD();
 6e0:	0e 94 79 01 	call	0x2f2	; 0x2f2 <SETBAUD>
		break;
 6e4:	08 95       	ret
		default:
		UART_Puts("\r\nIncorrect input\r\n");
 6e6:	89 eb       	ldi	r24, 0xB9	; 185
 6e8:	91 e0       	ldi	r25, 0x01	; 1
 6ea:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
 6ee:	08 95       	ret

000006f0 <DATAb>:
	}

}

void DATAb(void)
{
 6f0:	cf 93       	push	r28
 6f2:	df 93       	push	r29
	UART_Puts("\r\n# of Data Bits\r\n(1)5-bits\r\n(2)6-bits\r\n(3)7-bits\r\n(4)8-bits\r\n(5)9-bits\r\n");
 6f4:	8d ec       	ldi	r24, 0xCD	; 205
 6f6:	91 e0       	ldi	r25, 0x01	; 1
 6f8:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
	ASCII = '\0';
 6fc:	10 92 68 03 	sts	0x0368, r1	; 0x800368 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 700:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>

void DATAb(void)
{
	UART_Puts("\r\n# of Data Bits\r\n(1)5-bits\r\n(2)6-bits\r\n(3)7-bits\r\n(4)8-bits\r\n(5)9-bits\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 704:	80 91 68 03 	lds	r24, 0x0368	; 0x800368 <ASCII>
 708:	88 23       	and	r24, r24
 70a:	d1 f3       	breq	.-12     	; 0x700 <DATAb+0x10>
	{
		UART_Get();
	}
	switch (ASCII)
 70c:	83 33       	cpi	r24, 0x33	; 51
 70e:	a9 f1       	breq	.+106    	; 0x77a <DATAb+0x8a>
 710:	28 f4       	brcc	.+10     	; 0x71c <DATAb+0x2c>
 712:	81 33       	cpi	r24, 0x31	; 49
 714:	51 f0       	breq	.+20     	; 0x72a <DATAb+0x3a>
 716:	82 33       	cpi	r24, 0x32	; 50
 718:	c9 f0       	breq	.+50     	; 0x74c <DATAb+0x5c>
 71a:	68 c0       	rjmp	.+208    	; 0x7ec <DATAb+0xfc>
 71c:	84 33       	cpi	r24, 0x34	; 52
 71e:	09 f4       	brne	.+2      	; 0x722 <DATAb+0x32>
 720:	43 c0       	rjmp	.+134    	; 0x7a8 <DATAb+0xb8>
 722:	85 33       	cpi	r24, 0x35	; 53
 724:	09 f4       	brne	.+2      	; 0x728 <DATAb+0x38>
 726:	51 c0       	rjmp	.+162    	; 0x7ca <DATAb+0xda>
 728:	61 c0       	rjmp	.+194    	; 0x7ec <DATAb+0xfc>
	{
		case '1':
		USARTDATA = 6;
 72a:	86 e0       	ldi	r24, 0x06	; 6
 72c:	90 e0       	ldi	r25, 0x00	; 0
 72e:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <__data_end+0x1>
 732:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <__data_end>
		CLEARC();
 736:	0e 94 5d 01 	call	0x2ba	; 0x2ba <CLEARC>
		USARTDATA = 4;
 73a:	84 e0       	ldi	r24, 0x04	; 4
 73c:	90 e0       	ldi	r25, 0x00	; 0
 73e:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <__data_end+0x1>
 742:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <__data_end>
		CLEARB();
 746:	0e 94 71 01 	call	0x2e2	; 0x2e2 <CLEARB>
		break;
 74a:	54 c0       	rjmp	.+168    	; 0x7f4 <DATAb+0x104>
		case '2':
		USARTDATA = 4;
 74c:	c4 e0       	ldi	r28, 0x04	; 4
 74e:	d0 e0       	ldi	r29, 0x00	; 0
 750:	d0 93 61 03 	sts	0x0361, r29	; 0x800361 <__data_end+0x1>
 754:	c0 93 60 03 	sts	0x0360, r28	; 0x800360 <__data_end>
		CLEARC();
 758:	0e 94 5d 01 	call	0x2ba	; 0x2ba <CLEARC>
		USARTDATA = 2;
 75c:	82 e0       	ldi	r24, 0x02	; 2
 75e:	90 e0       	ldi	r25, 0x00	; 0
 760:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <__data_end+0x1>
 764:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <__data_end>
		SETC();
 768:	0e 94 55 01 	call	0x2aa	; 0x2aa <SETC>
		USARTDATA = 4;
 76c:	d0 93 61 03 	sts	0x0361, r29	; 0x800361 <__data_end+0x1>
 770:	c0 93 60 03 	sts	0x0360, r28	; 0x800360 <__data_end>
		CLEARB();
 774:	0e 94 71 01 	call	0x2e2	; 0x2e2 <CLEARB>
		break;
 778:	3d c0       	rjmp	.+122    	; 0x7f4 <DATAb+0x104>
		case '3':
		USARTDATA = 4;
 77a:	c4 e0       	ldi	r28, 0x04	; 4
 77c:	d0 e0       	ldi	r29, 0x00	; 0
 77e:	d0 93 61 03 	sts	0x0361, r29	; 0x800361 <__data_end+0x1>
 782:	c0 93 60 03 	sts	0x0360, r28	; 0x800360 <__data_end>
		SETC();
 786:	0e 94 55 01 	call	0x2aa	; 0x2aa <SETC>
		USARTDATA = 2;
 78a:	82 e0       	ldi	r24, 0x02	; 2
 78c:	90 e0       	ldi	r25, 0x00	; 0
 78e:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <__data_end+0x1>
 792:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <__data_end>
		CLEARC();
 796:	0e 94 5d 01 	call	0x2ba	; 0x2ba <CLEARC>
		USARTDATA = 4;
 79a:	d0 93 61 03 	sts	0x0361, r29	; 0x800361 <__data_end+0x1>
 79e:	c0 93 60 03 	sts	0x0360, r28	; 0x800360 <__data_end>
		CLEARB();
 7a2:	0e 94 71 01 	call	0x2e2	; 0x2e2 <CLEARB>
		break;
 7a6:	26 c0       	rjmp	.+76     	; 0x7f4 <DATAb+0x104>
		case '4':
		USARTDATA = 6;
 7a8:	86 e0       	ldi	r24, 0x06	; 6
 7aa:	90 e0       	ldi	r25, 0x00	; 0
 7ac:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <__data_end+0x1>
 7b0:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <__data_end>
		SETC();
 7b4:	0e 94 55 01 	call	0x2aa	; 0x2aa <SETC>
		USARTDATA = 4;
 7b8:	84 e0       	ldi	r24, 0x04	; 4
 7ba:	90 e0       	ldi	r25, 0x00	; 0
 7bc:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <__data_end+0x1>
 7c0:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <__data_end>
		CLEARB();
 7c4:	0e 94 71 01 	call	0x2e2	; 0x2e2 <CLEARB>
		break;
 7c8:	15 c0       	rjmp	.+42     	; 0x7f4 <DATAb+0x104>
		case '5':
		USARTDATA = 6;
 7ca:	86 e0       	ldi	r24, 0x06	; 6
 7cc:	90 e0       	ldi	r25, 0x00	; 0
 7ce:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <__data_end+0x1>
 7d2:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <__data_end>
		SETC();
 7d6:	0e 94 55 01 	call	0x2aa	; 0x2aa <SETC>
		USARTDATA = 4;
 7da:	84 e0       	ldi	r24, 0x04	; 4
 7dc:	90 e0       	ldi	r25, 0x00	; 0
 7de:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <__data_end+0x1>
 7e2:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <__data_end>
		SETB();
 7e6:	0e 94 67 01 	call	0x2ce	; 0x2ce <SETB>
		break;
 7ea:	04 c0       	rjmp	.+8      	; 0x7f4 <DATAb+0x104>
		default:
		UART_Puts("\r\nIncorrect input\r\n");
 7ec:	89 eb       	ldi	r24, 0xB9	; 185
 7ee:	91 e0       	ldi	r25, 0x01	; 1
 7f0:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
		break;
	}
}
 7f4:	df 91       	pop	r29
 7f6:	cf 91       	pop	r28
 7f8:	08 95       	ret

000007fa <PARITY>:

void PARITY(void)
{
	UART_Puts("\r\nParity\r\n(1)even\r\n(2)odd\r\n(3)none\r\n");
 7fa:	87 e1       	ldi	r24, 0x17	; 23
 7fc:	92 e0       	ldi	r25, 0x02	; 2
 7fe:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
	ASCII = '\0';
 802:	10 92 68 03 	sts	0x0368, r1	; 0x800368 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 806:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>

void PARITY(void)
{
	UART_Puts("\r\nParity\r\n(1)even\r\n(2)odd\r\n(3)none\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 80a:	80 91 68 03 	lds	r24, 0x0368	; 0x800368 <ASCII>
 80e:	88 23       	and	r24, r24
 810:	d1 f3       	breq	.-12     	; 0x806 <PARITY+0xc>
	{
		UART_Get();
	}
	switch (ASCII)
 812:	82 33       	cpi	r24, 0x32	; 50
 814:	69 f0       	breq	.+26     	; 0x830 <PARITY+0x36>
 816:	83 33       	cpi	r24, 0x33	; 51
 818:	e1 f0       	breq	.+56     	; 0x852 <PARITY+0x58>
 81a:	81 33       	cpi	r24, 0x31	; 49
 81c:	19 f5       	brne	.+70     	; 0x864 <PARITY+0x6a>
	{
		case '1':
		USARTDATA = 48;
 81e:	80 e3       	ldi	r24, 0x30	; 48
 820:	90 e0       	ldi	r25, 0x00	; 0
 822:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <__data_end+0x1>
 826:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <__data_end>
		CLEARC();
 82a:	0e 94 5d 01 	call	0x2ba	; 0x2ba <CLEARC>
		break;
 82e:	08 95       	ret
		case '2':
		USARTDATA = 32;
 830:	80 e2       	ldi	r24, 0x20	; 32
 832:	90 e0       	ldi	r25, 0x00	; 0
 834:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <__data_end+0x1>
 838:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <__data_end>
		SETC();
 83c:	0e 94 55 01 	call	0x2aa	; 0x2aa <SETC>
		USARTDATA = 16;
 840:	80 e1       	ldi	r24, 0x10	; 16
 842:	90 e0       	ldi	r25, 0x00	; 0
 844:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <__data_end+0x1>
 848:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <__data_end>
		CLEARC();
 84c:	0e 94 5d 01 	call	0x2ba	; 0x2ba <CLEARC>
		break;
 850:	08 95       	ret
		case '3':
		USARTDATA = 48;
 852:	80 e3       	ldi	r24, 0x30	; 48
 854:	90 e0       	ldi	r25, 0x00	; 0
 856:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <__data_end+0x1>
 85a:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <__data_end>
		SETC();
 85e:	0e 94 55 01 	call	0x2aa	; 0x2aa <SETC>
		break;
 862:	08 95       	ret
		default:
		UART_Puts("\r\nIncorrect input\r\n");
 864:	89 eb       	ldi	r24, 0xB9	; 185
 866:	91 e0       	ldi	r25, 0x01	; 1
 868:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
 86c:	08 95       	ret

0000086e <STOPb>:
	}
}

void STOPb(void)
{
	USARTDATA = 8;
 86e:	88 e0       	ldi	r24, 0x08	; 8
 870:	90 e0       	ldi	r25, 0x00	; 0
 872:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <__data_end+0x1>
 876:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <__data_end>
	UART_Puts("\r\n# of Stop bits\r\n(1)1-bit\r\n(2)2-bits\r\n");
 87a:	8c e3       	ldi	r24, 0x3C	; 60
 87c:	92 e0       	ldi	r25, 0x02	; 2
 87e:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
	ASCII = '\0';
 882:	10 92 68 03 	sts	0x0368, r1	; 0x800368 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 886:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>
void STOPb(void)
{
	USARTDATA = 8;
	UART_Puts("\r\n# of Stop bits\r\n(1)1-bit\r\n(2)2-bits\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 88a:	80 91 68 03 	lds	r24, 0x0368	; 0x800368 <ASCII>
 88e:	88 23       	and	r24, r24
 890:	d1 f3       	breq	.-12     	; 0x886 <STOPb+0x18>
	{
		UART_Get();
	}
	switch (ASCII)
 892:	81 33       	cpi	r24, 0x31	; 49
 894:	19 f0       	breq	.+6      	; 0x89c <STOPb+0x2e>
 896:	82 33       	cpi	r24, 0x32	; 50
 898:	21 f0       	breq	.+8      	; 0x8a2 <STOPb+0x34>
 89a:	06 c0       	rjmp	.+12     	; 0x8a8 <STOPb+0x3a>
	{
		case '1': CLEARC();
 89c:	0e 94 5d 01 	call	0x2ba	; 0x2ba <CLEARC>
		break;
 8a0:	08 95       	ret
		case '2': SETC();
 8a2:	0e 94 55 01 	call	0x2aa	; 0x2aa <SETC>
		break;
 8a6:	08 95       	ret
		default:
		UART_Puts("\r\nIncorrect input\r\n");
 8a8:	89 eb       	ldi	r24, 0xB9	; 185
 8aa:	91 e0       	ldi	r25, 0x01	; 1
 8ac:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
 8b0:	08 95       	ret

000008b2 <USART>:
	}
}

void USART(void)
{
	UART_Puts("\r\nUSART Config\r\n(1)Baud Rate\r\n(2)# of Data bits\r\n(3)Parity\r\n(4)# of Stop Bits\r\n");
 8b2:	84 e6       	ldi	r24, 0x64	; 100
 8b4:	92 e0       	ldi	r25, 0x02	; 2
 8b6:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
	ASCII = '\0';
 8ba:	10 92 68 03 	sts	0x0368, r1	; 0x800368 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 8be:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>

void USART(void)
{
	UART_Puts("\r\nUSART Config\r\n(1)Baud Rate\r\n(2)# of Data bits\r\n(3)Parity\r\n(4)# of Stop Bits\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 8c2:	80 91 68 03 	lds	r24, 0x0368	; 0x800368 <ASCII>
 8c6:	88 23       	and	r24, r24
 8c8:	d1 f3       	breq	.-12     	; 0x8be <USART+0xc>
	{
		UART_Get();
	}
	switch (ASCII)
 8ca:	82 33       	cpi	r24, 0x32	; 50
 8cc:	61 f0       	breq	.+24     	; 0x8e6 <USART+0x34>
 8ce:	18 f4       	brcc	.+6      	; 0x8d6 <USART+0x24>
 8d0:	81 33       	cpi	r24, 0x31	; 49
 8d2:	31 f0       	breq	.+12     	; 0x8e0 <USART+0x2e>
 8d4:	11 c0       	rjmp	.+34     	; 0x8f8 <USART+0x46>
 8d6:	83 33       	cpi	r24, 0x33	; 51
 8d8:	49 f0       	breq	.+18     	; 0x8ec <USART+0x3a>
 8da:	84 33       	cpi	r24, 0x34	; 52
 8dc:	51 f0       	breq	.+20     	; 0x8f2 <USART+0x40>
 8de:	0c c0       	rjmp	.+24     	; 0x8f8 <USART+0x46>
	{
		case '1': BAUD();
 8e0:	0e 94 36 03 	call	0x66c	; 0x66c <BAUD>
		break;
 8e4:	08 95       	ret
		case '2': DATAb();
 8e6:	0e 94 78 03 	call	0x6f0	; 0x6f0 <DATAb>
		break;
 8ea:	08 95       	ret
		case '3': PARITY();
 8ec:	0e 94 fd 03 	call	0x7fa	; 0x7fa <PARITY>
		break;
 8f0:	08 95       	ret
		case '4': STOPb();
 8f2:	0e 94 37 04 	call	0x86e	; 0x86e <STOPb>
		break;
 8f6:	08 95       	ret
		default:
		UART_Puts("\r\nIncorrect input\r\n");
 8f8:	89 eb       	ldi	r24, 0xB9	; 185
 8fa:	91 e0       	ldi	r25, 0x01	; 1
 8fc:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
 900:	08 95       	ret

00000902 <Command>:
	}
}

void Command(void)					//command interpreter
{
	UART_On();
 902:	0e 94 fe 00 	call	0x1fc	; 0x1fc <UART_On>
	UART_Puts(MS3);
 906:	80 ee       	ldi	r24, 0xE0	; 224
 908:	92 e0       	ldi	r25, 0x02	; 2
 90a:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
	ASCII = '\0';						
 90e:	10 92 68 03 	sts	0x0368, r1	; 0x800368 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 912:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>
void Command(void)					//command interpreter
{
	UART_On();
	UART_Puts(MS3);
	ASCII = '\0';						
	while (ASCII == '\0')
 916:	80 91 68 03 	lds	r24, 0x0368	; 0x800368 <ASCII>
 91a:	88 23       	and	r24, r24
 91c:	d1 f3       	breq	.-12     	; 0x912 <Command+0x10>
	{
		UART_Get();
	}
	switch (ASCII)
 91e:	85 36       	cpi	r24, 0x65	; 101
 920:	79 f0       	breq	.+30     	; 0x940 <Command+0x3e>
 922:	18 f4       	brcc	.+6      	; 0x92a <Command+0x28>
 924:	81 36       	cpi	r24, 0x61	; 97
 926:	49 f0       	breq	.+18     	; 0x93a <Command+0x38>
 928:	11 c0       	rjmp	.+34     	; 0x94c <Command+0x4a>
 92a:	8c 36       	cpi	r24, 0x6C	; 108
 92c:	19 f0       	breq	.+6      	; 0x934 <Command+0x32>
 92e:	85 37       	cpi	r24, 0x75	; 117
 930:	51 f0       	breq	.+20     	; 0x946 <Command+0x44>
 932:	0c c0       	rjmp	.+24     	; 0x94c <Command+0x4a>
	{
		case 'L' | 'l': LCD();
 934:	0e 94 b6 01 	call	0x36c	; 0x36c <LCD>
		break;
 938:	08 95       	ret
		case 'A' | 'a': Temperature_ADC();
 93a:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <Temperature_ADC>
		break;
 93e:	08 95       	ret
		case 'E' | 'e': EEPROM();
 940:	0e 94 ca 02 	call	0x594	; 0x594 <EEPROM>
		break;
 944:	08 95       	ret
		case 'U' | 'u': USART();
 946:	0e 94 59 04 	call	0x8b2	; 0x8b2 <USART>
		break;
 94a:	08 95       	ret
		default:
		UART_Puts(MS5);
 94c:	87 eb       	ldi	r24, 0xB7	; 183
 94e:	92 e0       	ldi	r25, 0x02	; 2
 950:	0e 94 82 01 	call	0x304	; 0x304 <UART_Puts>
		HELP();
 954:	0e 94 b1 01 	call	0x362	; 0x362 <HELP>
 958:	08 95       	ret

0000095a <main>:
	}
}

int main(void)
{
	Mega328P_Init();
 95a:	0e 94 a6 00 	call	0x14c	; 0x14c <Mega328P_Init>
	Banner();
 95e:	0e 94 a4 01 	call	0x348	; 0x348 <Banner>
	while (1)
	{
		Command();				//infinite command loop
 962:	0e 94 81 04 	call	0x902	; 0x902 <Command>
 966:	fd cf       	rjmp	.-6      	; 0x962 <main+0x8>

00000968 <__subsf3>:
 968:	50 58       	subi	r21, 0x80	; 128

0000096a <__addsf3>:
 96a:	bb 27       	eor	r27, r27
 96c:	aa 27       	eor	r26, r26
 96e:	0e 94 cc 04 	call	0x998	; 0x998 <__addsf3x>
 972:	0c 94 1d 06 	jmp	0xc3a	; 0xc3a <__fp_round>
 976:	0e 94 0f 06 	call	0xc1e	; 0xc1e <__fp_pscA>
 97a:	38 f0       	brcs	.+14     	; 0x98a <__addsf3+0x20>
 97c:	0e 94 16 06 	call	0xc2c	; 0xc2c <__fp_pscB>
 980:	20 f0       	brcs	.+8      	; 0x98a <__addsf3+0x20>
 982:	39 f4       	brne	.+14     	; 0x992 <__addsf3+0x28>
 984:	9f 3f       	cpi	r25, 0xFF	; 255
 986:	19 f4       	brne	.+6      	; 0x98e <__addsf3+0x24>
 988:	26 f4       	brtc	.+8      	; 0x992 <__addsf3+0x28>
 98a:	0c 94 0c 06 	jmp	0xc18	; 0xc18 <__fp_nan>
 98e:	0e f4       	brtc	.+2      	; 0x992 <__addsf3+0x28>
 990:	e0 95       	com	r30
 992:	e7 fb       	bst	r30, 7
 994:	0c 94 06 06 	jmp	0xc0c	; 0xc0c <__fp_inf>

00000998 <__addsf3x>:
 998:	e9 2f       	mov	r30, r25
 99a:	0e 94 2e 06 	call	0xc5c	; 0xc5c <__fp_split3>
 99e:	58 f3       	brcs	.-42     	; 0x976 <__addsf3+0xc>
 9a0:	ba 17       	cp	r27, r26
 9a2:	62 07       	cpc	r22, r18
 9a4:	73 07       	cpc	r23, r19
 9a6:	84 07       	cpc	r24, r20
 9a8:	95 07       	cpc	r25, r21
 9aa:	20 f0       	brcs	.+8      	; 0x9b4 <__addsf3x+0x1c>
 9ac:	79 f4       	brne	.+30     	; 0x9cc <__addsf3x+0x34>
 9ae:	a6 f5       	brtc	.+104    	; 0xa18 <__addsf3x+0x80>
 9b0:	0c 94 50 06 	jmp	0xca0	; 0xca0 <__fp_zero>
 9b4:	0e f4       	brtc	.+2      	; 0x9b8 <__addsf3x+0x20>
 9b6:	e0 95       	com	r30
 9b8:	0b 2e       	mov	r0, r27
 9ba:	ba 2f       	mov	r27, r26
 9bc:	a0 2d       	mov	r26, r0
 9be:	0b 01       	movw	r0, r22
 9c0:	b9 01       	movw	r22, r18
 9c2:	90 01       	movw	r18, r0
 9c4:	0c 01       	movw	r0, r24
 9c6:	ca 01       	movw	r24, r20
 9c8:	a0 01       	movw	r20, r0
 9ca:	11 24       	eor	r1, r1
 9cc:	ff 27       	eor	r31, r31
 9ce:	59 1b       	sub	r21, r25
 9d0:	99 f0       	breq	.+38     	; 0x9f8 <__addsf3x+0x60>
 9d2:	59 3f       	cpi	r21, 0xF9	; 249
 9d4:	50 f4       	brcc	.+20     	; 0x9ea <__addsf3x+0x52>
 9d6:	50 3e       	cpi	r21, 0xE0	; 224
 9d8:	68 f1       	brcs	.+90     	; 0xa34 <__addsf3x+0x9c>
 9da:	1a 16       	cp	r1, r26
 9dc:	f0 40       	sbci	r31, 0x00	; 0
 9de:	a2 2f       	mov	r26, r18
 9e0:	23 2f       	mov	r18, r19
 9e2:	34 2f       	mov	r19, r20
 9e4:	44 27       	eor	r20, r20
 9e6:	58 5f       	subi	r21, 0xF8	; 248
 9e8:	f3 cf       	rjmp	.-26     	; 0x9d0 <__addsf3x+0x38>
 9ea:	46 95       	lsr	r20
 9ec:	37 95       	ror	r19
 9ee:	27 95       	ror	r18
 9f0:	a7 95       	ror	r26
 9f2:	f0 40       	sbci	r31, 0x00	; 0
 9f4:	53 95       	inc	r21
 9f6:	c9 f7       	brne	.-14     	; 0x9ea <__addsf3x+0x52>
 9f8:	7e f4       	brtc	.+30     	; 0xa18 <__addsf3x+0x80>
 9fa:	1f 16       	cp	r1, r31
 9fc:	ba 0b       	sbc	r27, r26
 9fe:	62 0b       	sbc	r22, r18
 a00:	73 0b       	sbc	r23, r19
 a02:	84 0b       	sbc	r24, r20
 a04:	ba f0       	brmi	.+46     	; 0xa34 <__addsf3x+0x9c>
 a06:	91 50       	subi	r25, 0x01	; 1
 a08:	a1 f0       	breq	.+40     	; 0xa32 <__addsf3x+0x9a>
 a0a:	ff 0f       	add	r31, r31
 a0c:	bb 1f       	adc	r27, r27
 a0e:	66 1f       	adc	r22, r22
 a10:	77 1f       	adc	r23, r23
 a12:	88 1f       	adc	r24, r24
 a14:	c2 f7       	brpl	.-16     	; 0xa06 <__addsf3x+0x6e>
 a16:	0e c0       	rjmp	.+28     	; 0xa34 <__addsf3x+0x9c>
 a18:	ba 0f       	add	r27, r26
 a1a:	62 1f       	adc	r22, r18
 a1c:	73 1f       	adc	r23, r19
 a1e:	84 1f       	adc	r24, r20
 a20:	48 f4       	brcc	.+18     	; 0xa34 <__addsf3x+0x9c>
 a22:	87 95       	ror	r24
 a24:	77 95       	ror	r23
 a26:	67 95       	ror	r22
 a28:	b7 95       	ror	r27
 a2a:	f7 95       	ror	r31
 a2c:	9e 3f       	cpi	r25, 0xFE	; 254
 a2e:	08 f0       	brcs	.+2      	; 0xa32 <__addsf3x+0x9a>
 a30:	b0 cf       	rjmp	.-160    	; 0x992 <__addsf3+0x28>
 a32:	93 95       	inc	r25
 a34:	88 0f       	add	r24, r24
 a36:	08 f0       	brcs	.+2      	; 0xa3a <__addsf3x+0xa2>
 a38:	99 27       	eor	r25, r25
 a3a:	ee 0f       	add	r30, r30
 a3c:	97 95       	ror	r25
 a3e:	87 95       	ror	r24
 a40:	08 95       	ret

00000a42 <__divsf3>:
 a42:	0e 94 35 05 	call	0xa6a	; 0xa6a <__divsf3x>
 a46:	0c 94 1d 06 	jmp	0xc3a	; 0xc3a <__fp_round>
 a4a:	0e 94 16 06 	call	0xc2c	; 0xc2c <__fp_pscB>
 a4e:	58 f0       	brcs	.+22     	; 0xa66 <__divsf3+0x24>
 a50:	0e 94 0f 06 	call	0xc1e	; 0xc1e <__fp_pscA>
 a54:	40 f0       	brcs	.+16     	; 0xa66 <__divsf3+0x24>
 a56:	29 f4       	brne	.+10     	; 0xa62 <__divsf3+0x20>
 a58:	5f 3f       	cpi	r21, 0xFF	; 255
 a5a:	29 f0       	breq	.+10     	; 0xa66 <__divsf3+0x24>
 a5c:	0c 94 06 06 	jmp	0xc0c	; 0xc0c <__fp_inf>
 a60:	51 11       	cpse	r21, r1
 a62:	0c 94 51 06 	jmp	0xca2	; 0xca2 <__fp_szero>
 a66:	0c 94 0c 06 	jmp	0xc18	; 0xc18 <__fp_nan>

00000a6a <__divsf3x>:
 a6a:	0e 94 2e 06 	call	0xc5c	; 0xc5c <__fp_split3>
 a6e:	68 f3       	brcs	.-38     	; 0xa4a <__divsf3+0x8>

00000a70 <__divsf3_pse>:
 a70:	99 23       	and	r25, r25
 a72:	b1 f3       	breq	.-20     	; 0xa60 <__divsf3+0x1e>
 a74:	55 23       	and	r21, r21
 a76:	91 f3       	breq	.-28     	; 0xa5c <__divsf3+0x1a>
 a78:	95 1b       	sub	r25, r21
 a7a:	55 0b       	sbc	r21, r21
 a7c:	bb 27       	eor	r27, r27
 a7e:	aa 27       	eor	r26, r26
 a80:	62 17       	cp	r22, r18
 a82:	73 07       	cpc	r23, r19
 a84:	84 07       	cpc	r24, r20
 a86:	38 f0       	brcs	.+14     	; 0xa96 <__divsf3_pse+0x26>
 a88:	9f 5f       	subi	r25, 0xFF	; 255
 a8a:	5f 4f       	sbci	r21, 0xFF	; 255
 a8c:	22 0f       	add	r18, r18
 a8e:	33 1f       	adc	r19, r19
 a90:	44 1f       	adc	r20, r20
 a92:	aa 1f       	adc	r26, r26
 a94:	a9 f3       	breq	.-22     	; 0xa80 <__divsf3_pse+0x10>
 a96:	35 d0       	rcall	.+106    	; 0xb02 <__divsf3_pse+0x92>
 a98:	0e 2e       	mov	r0, r30
 a9a:	3a f0       	brmi	.+14     	; 0xaaa <__divsf3_pse+0x3a>
 a9c:	e0 e8       	ldi	r30, 0x80	; 128
 a9e:	32 d0       	rcall	.+100    	; 0xb04 <__divsf3_pse+0x94>
 aa0:	91 50       	subi	r25, 0x01	; 1
 aa2:	50 40       	sbci	r21, 0x00	; 0
 aa4:	e6 95       	lsr	r30
 aa6:	00 1c       	adc	r0, r0
 aa8:	ca f7       	brpl	.-14     	; 0xa9c <__divsf3_pse+0x2c>
 aaa:	2b d0       	rcall	.+86     	; 0xb02 <__divsf3_pse+0x92>
 aac:	fe 2f       	mov	r31, r30
 aae:	29 d0       	rcall	.+82     	; 0xb02 <__divsf3_pse+0x92>
 ab0:	66 0f       	add	r22, r22
 ab2:	77 1f       	adc	r23, r23
 ab4:	88 1f       	adc	r24, r24
 ab6:	bb 1f       	adc	r27, r27
 ab8:	26 17       	cp	r18, r22
 aba:	37 07       	cpc	r19, r23
 abc:	48 07       	cpc	r20, r24
 abe:	ab 07       	cpc	r26, r27
 ac0:	b0 e8       	ldi	r27, 0x80	; 128
 ac2:	09 f0       	breq	.+2      	; 0xac6 <__divsf3_pse+0x56>
 ac4:	bb 0b       	sbc	r27, r27
 ac6:	80 2d       	mov	r24, r0
 ac8:	bf 01       	movw	r22, r30
 aca:	ff 27       	eor	r31, r31
 acc:	93 58       	subi	r25, 0x83	; 131
 ace:	5f 4f       	sbci	r21, 0xFF	; 255
 ad0:	3a f0       	brmi	.+14     	; 0xae0 <__divsf3_pse+0x70>
 ad2:	9e 3f       	cpi	r25, 0xFE	; 254
 ad4:	51 05       	cpc	r21, r1
 ad6:	78 f0       	brcs	.+30     	; 0xaf6 <__divsf3_pse+0x86>
 ad8:	0c 94 06 06 	jmp	0xc0c	; 0xc0c <__fp_inf>
 adc:	0c 94 51 06 	jmp	0xca2	; 0xca2 <__fp_szero>
 ae0:	5f 3f       	cpi	r21, 0xFF	; 255
 ae2:	e4 f3       	brlt	.-8      	; 0xadc <__divsf3_pse+0x6c>
 ae4:	98 3e       	cpi	r25, 0xE8	; 232
 ae6:	d4 f3       	brlt	.-12     	; 0xadc <__divsf3_pse+0x6c>
 ae8:	86 95       	lsr	r24
 aea:	77 95       	ror	r23
 aec:	67 95       	ror	r22
 aee:	b7 95       	ror	r27
 af0:	f7 95       	ror	r31
 af2:	9f 5f       	subi	r25, 0xFF	; 255
 af4:	c9 f7       	brne	.-14     	; 0xae8 <__divsf3_pse+0x78>
 af6:	88 0f       	add	r24, r24
 af8:	91 1d       	adc	r25, r1
 afa:	96 95       	lsr	r25
 afc:	87 95       	ror	r24
 afe:	97 f9       	bld	r25, 7
 b00:	08 95       	ret
 b02:	e1 e0       	ldi	r30, 0x01	; 1
 b04:	66 0f       	add	r22, r22
 b06:	77 1f       	adc	r23, r23
 b08:	88 1f       	adc	r24, r24
 b0a:	bb 1f       	adc	r27, r27
 b0c:	62 17       	cp	r22, r18
 b0e:	73 07       	cpc	r23, r19
 b10:	84 07       	cpc	r24, r20
 b12:	ba 07       	cpc	r27, r26
 b14:	20 f0       	brcs	.+8      	; 0xb1e <__divsf3_pse+0xae>
 b16:	62 1b       	sub	r22, r18
 b18:	73 0b       	sbc	r23, r19
 b1a:	84 0b       	sbc	r24, r20
 b1c:	ba 0b       	sbc	r27, r26
 b1e:	ee 1f       	adc	r30, r30
 b20:	88 f7       	brcc	.-30     	; 0xb04 <__divsf3_pse+0x94>
 b22:	e0 95       	com	r30
 b24:	08 95       	ret

00000b26 <__fixsfsi>:
 b26:	0e 94 9a 05 	call	0xb34	; 0xb34 <__fixunssfsi>
 b2a:	68 94       	set
 b2c:	b1 11       	cpse	r27, r1
 b2e:	0c 94 51 06 	jmp	0xca2	; 0xca2 <__fp_szero>
 b32:	08 95       	ret

00000b34 <__fixunssfsi>:
 b34:	0e 94 36 06 	call	0xc6c	; 0xc6c <__fp_splitA>
 b38:	88 f0       	brcs	.+34     	; 0xb5c <__fixunssfsi+0x28>
 b3a:	9f 57       	subi	r25, 0x7F	; 127
 b3c:	98 f0       	brcs	.+38     	; 0xb64 <__fixunssfsi+0x30>
 b3e:	b9 2f       	mov	r27, r25
 b40:	99 27       	eor	r25, r25
 b42:	b7 51       	subi	r27, 0x17	; 23
 b44:	b0 f0       	brcs	.+44     	; 0xb72 <__fixunssfsi+0x3e>
 b46:	e1 f0       	breq	.+56     	; 0xb80 <__fixunssfsi+0x4c>
 b48:	66 0f       	add	r22, r22
 b4a:	77 1f       	adc	r23, r23
 b4c:	88 1f       	adc	r24, r24
 b4e:	99 1f       	adc	r25, r25
 b50:	1a f0       	brmi	.+6      	; 0xb58 <__fixunssfsi+0x24>
 b52:	ba 95       	dec	r27
 b54:	c9 f7       	brne	.-14     	; 0xb48 <__fixunssfsi+0x14>
 b56:	14 c0       	rjmp	.+40     	; 0xb80 <__fixunssfsi+0x4c>
 b58:	b1 30       	cpi	r27, 0x01	; 1
 b5a:	91 f0       	breq	.+36     	; 0xb80 <__fixunssfsi+0x4c>
 b5c:	0e 94 50 06 	call	0xca0	; 0xca0 <__fp_zero>
 b60:	b1 e0       	ldi	r27, 0x01	; 1
 b62:	08 95       	ret
 b64:	0c 94 50 06 	jmp	0xca0	; 0xca0 <__fp_zero>
 b68:	67 2f       	mov	r22, r23
 b6a:	78 2f       	mov	r23, r24
 b6c:	88 27       	eor	r24, r24
 b6e:	b8 5f       	subi	r27, 0xF8	; 248
 b70:	39 f0       	breq	.+14     	; 0xb80 <__fixunssfsi+0x4c>
 b72:	b9 3f       	cpi	r27, 0xF9	; 249
 b74:	cc f3       	brlt	.-14     	; 0xb68 <__fixunssfsi+0x34>
 b76:	86 95       	lsr	r24
 b78:	77 95       	ror	r23
 b7a:	67 95       	ror	r22
 b7c:	b3 95       	inc	r27
 b7e:	d9 f7       	brne	.-10     	; 0xb76 <__fixunssfsi+0x42>
 b80:	3e f4       	brtc	.+14     	; 0xb90 <__fixunssfsi+0x5c>
 b82:	90 95       	com	r25
 b84:	80 95       	com	r24
 b86:	70 95       	com	r23
 b88:	61 95       	neg	r22
 b8a:	7f 4f       	sbci	r23, 0xFF	; 255
 b8c:	8f 4f       	sbci	r24, 0xFF	; 255
 b8e:	9f 4f       	sbci	r25, 0xFF	; 255
 b90:	08 95       	ret

00000b92 <__floatunsisf>:
 b92:	e8 94       	clt
 b94:	09 c0       	rjmp	.+18     	; 0xba8 <__floatsisf+0x12>

00000b96 <__floatsisf>:
 b96:	97 fb       	bst	r25, 7
 b98:	3e f4       	brtc	.+14     	; 0xba8 <__floatsisf+0x12>
 b9a:	90 95       	com	r25
 b9c:	80 95       	com	r24
 b9e:	70 95       	com	r23
 ba0:	61 95       	neg	r22
 ba2:	7f 4f       	sbci	r23, 0xFF	; 255
 ba4:	8f 4f       	sbci	r24, 0xFF	; 255
 ba6:	9f 4f       	sbci	r25, 0xFF	; 255
 ba8:	99 23       	and	r25, r25
 baa:	a9 f0       	breq	.+42     	; 0xbd6 <__floatsisf+0x40>
 bac:	f9 2f       	mov	r31, r25
 bae:	96 e9       	ldi	r25, 0x96	; 150
 bb0:	bb 27       	eor	r27, r27
 bb2:	93 95       	inc	r25
 bb4:	f6 95       	lsr	r31
 bb6:	87 95       	ror	r24
 bb8:	77 95       	ror	r23
 bba:	67 95       	ror	r22
 bbc:	b7 95       	ror	r27
 bbe:	f1 11       	cpse	r31, r1
 bc0:	f8 cf       	rjmp	.-16     	; 0xbb2 <__floatsisf+0x1c>
 bc2:	fa f4       	brpl	.+62     	; 0xc02 <__floatsisf+0x6c>
 bc4:	bb 0f       	add	r27, r27
 bc6:	11 f4       	brne	.+4      	; 0xbcc <__floatsisf+0x36>
 bc8:	60 ff       	sbrs	r22, 0
 bca:	1b c0       	rjmp	.+54     	; 0xc02 <__floatsisf+0x6c>
 bcc:	6f 5f       	subi	r22, 0xFF	; 255
 bce:	7f 4f       	sbci	r23, 0xFF	; 255
 bd0:	8f 4f       	sbci	r24, 0xFF	; 255
 bd2:	9f 4f       	sbci	r25, 0xFF	; 255
 bd4:	16 c0       	rjmp	.+44     	; 0xc02 <__floatsisf+0x6c>
 bd6:	88 23       	and	r24, r24
 bd8:	11 f0       	breq	.+4      	; 0xbde <__floatsisf+0x48>
 bda:	96 e9       	ldi	r25, 0x96	; 150
 bdc:	11 c0       	rjmp	.+34     	; 0xc00 <__floatsisf+0x6a>
 bde:	77 23       	and	r23, r23
 be0:	21 f0       	breq	.+8      	; 0xbea <__floatsisf+0x54>
 be2:	9e e8       	ldi	r25, 0x8E	; 142
 be4:	87 2f       	mov	r24, r23
 be6:	76 2f       	mov	r23, r22
 be8:	05 c0       	rjmp	.+10     	; 0xbf4 <__floatsisf+0x5e>
 bea:	66 23       	and	r22, r22
 bec:	71 f0       	breq	.+28     	; 0xc0a <__floatsisf+0x74>
 bee:	96 e8       	ldi	r25, 0x86	; 134
 bf0:	86 2f       	mov	r24, r22
 bf2:	70 e0       	ldi	r23, 0x00	; 0
 bf4:	60 e0       	ldi	r22, 0x00	; 0
 bf6:	2a f0       	brmi	.+10     	; 0xc02 <__floatsisf+0x6c>
 bf8:	9a 95       	dec	r25
 bfa:	66 0f       	add	r22, r22
 bfc:	77 1f       	adc	r23, r23
 bfe:	88 1f       	adc	r24, r24
 c00:	da f7       	brpl	.-10     	; 0xbf8 <__floatsisf+0x62>
 c02:	88 0f       	add	r24, r24
 c04:	96 95       	lsr	r25
 c06:	87 95       	ror	r24
 c08:	97 f9       	bld	r25, 7
 c0a:	08 95       	ret

00000c0c <__fp_inf>:
 c0c:	97 f9       	bld	r25, 7
 c0e:	9f 67       	ori	r25, 0x7F	; 127
 c10:	80 e8       	ldi	r24, 0x80	; 128
 c12:	70 e0       	ldi	r23, 0x00	; 0
 c14:	60 e0       	ldi	r22, 0x00	; 0
 c16:	08 95       	ret

00000c18 <__fp_nan>:
 c18:	9f ef       	ldi	r25, 0xFF	; 255
 c1a:	80 ec       	ldi	r24, 0xC0	; 192
 c1c:	08 95       	ret

00000c1e <__fp_pscA>:
 c1e:	00 24       	eor	r0, r0
 c20:	0a 94       	dec	r0
 c22:	16 16       	cp	r1, r22
 c24:	17 06       	cpc	r1, r23
 c26:	18 06       	cpc	r1, r24
 c28:	09 06       	cpc	r0, r25
 c2a:	08 95       	ret

00000c2c <__fp_pscB>:
 c2c:	00 24       	eor	r0, r0
 c2e:	0a 94       	dec	r0
 c30:	12 16       	cp	r1, r18
 c32:	13 06       	cpc	r1, r19
 c34:	14 06       	cpc	r1, r20
 c36:	05 06       	cpc	r0, r21
 c38:	08 95       	ret

00000c3a <__fp_round>:
 c3a:	09 2e       	mov	r0, r25
 c3c:	03 94       	inc	r0
 c3e:	00 0c       	add	r0, r0
 c40:	11 f4       	brne	.+4      	; 0xc46 <__fp_round+0xc>
 c42:	88 23       	and	r24, r24
 c44:	52 f0       	brmi	.+20     	; 0xc5a <__fp_round+0x20>
 c46:	bb 0f       	add	r27, r27
 c48:	40 f4       	brcc	.+16     	; 0xc5a <__fp_round+0x20>
 c4a:	bf 2b       	or	r27, r31
 c4c:	11 f4       	brne	.+4      	; 0xc52 <__fp_round+0x18>
 c4e:	60 ff       	sbrs	r22, 0
 c50:	04 c0       	rjmp	.+8      	; 0xc5a <__fp_round+0x20>
 c52:	6f 5f       	subi	r22, 0xFF	; 255
 c54:	7f 4f       	sbci	r23, 0xFF	; 255
 c56:	8f 4f       	sbci	r24, 0xFF	; 255
 c58:	9f 4f       	sbci	r25, 0xFF	; 255
 c5a:	08 95       	ret

00000c5c <__fp_split3>:
 c5c:	57 fd       	sbrc	r21, 7
 c5e:	90 58       	subi	r25, 0x80	; 128
 c60:	44 0f       	add	r20, r20
 c62:	55 1f       	adc	r21, r21
 c64:	59 f0       	breq	.+22     	; 0xc7c <__fp_splitA+0x10>
 c66:	5f 3f       	cpi	r21, 0xFF	; 255
 c68:	71 f0       	breq	.+28     	; 0xc86 <__fp_splitA+0x1a>
 c6a:	47 95       	ror	r20

00000c6c <__fp_splitA>:
 c6c:	88 0f       	add	r24, r24
 c6e:	97 fb       	bst	r25, 7
 c70:	99 1f       	adc	r25, r25
 c72:	61 f0       	breq	.+24     	; 0xc8c <__fp_splitA+0x20>
 c74:	9f 3f       	cpi	r25, 0xFF	; 255
 c76:	79 f0       	breq	.+30     	; 0xc96 <__fp_splitA+0x2a>
 c78:	87 95       	ror	r24
 c7a:	08 95       	ret
 c7c:	12 16       	cp	r1, r18
 c7e:	13 06       	cpc	r1, r19
 c80:	14 06       	cpc	r1, r20
 c82:	55 1f       	adc	r21, r21
 c84:	f2 cf       	rjmp	.-28     	; 0xc6a <__fp_split3+0xe>
 c86:	46 95       	lsr	r20
 c88:	f1 df       	rcall	.-30     	; 0xc6c <__fp_splitA>
 c8a:	08 c0       	rjmp	.+16     	; 0xc9c <__fp_splitA+0x30>
 c8c:	16 16       	cp	r1, r22
 c8e:	17 06       	cpc	r1, r23
 c90:	18 06       	cpc	r1, r24
 c92:	99 1f       	adc	r25, r25
 c94:	f1 cf       	rjmp	.-30     	; 0xc78 <__fp_splitA+0xc>
 c96:	86 95       	lsr	r24
 c98:	71 05       	cpc	r23, r1
 c9a:	61 05       	cpc	r22, r1
 c9c:	08 94       	sec
 c9e:	08 95       	ret

00000ca0 <__fp_zero>:
 ca0:	e8 94       	clt

00000ca2 <__fp_szero>:
 ca2:	bb 27       	eor	r27, r27
 ca4:	66 27       	eor	r22, r22
 ca6:	77 27       	eor	r23, r23
 ca8:	cb 01       	movw	r24, r22
 caa:	97 f9       	bld	r25, 7
 cac:	08 95       	ret
 cae:	16 f0       	brts	.+4      	; 0xcb4 <__fp_szero+0x12>
 cb0:	0c 94 14 07 	jmp	0xe28	; 0xe28 <__fp_mpack>
 cb4:	0c 94 0c 06 	jmp	0xc18	; 0xc18 <__fp_nan>
 cb8:	68 94       	set
 cba:	0c 94 06 06 	jmp	0xc0c	; 0xc0c <__fp_inf>

00000cbe <log>:
 cbe:	0e 94 36 06 	call	0xc6c	; 0xc6c <__fp_splitA>
 cc2:	a8 f3       	brcs	.-22     	; 0xcae <__fp_szero+0xc>
 cc4:	99 23       	and	r25, r25
 cc6:	c1 f3       	breq	.-16     	; 0xcb8 <__fp_szero+0x16>
 cc8:	ae f3       	brts	.-22     	; 0xcb4 <__fp_szero+0x12>
 cca:	df 93       	push	r29
 ccc:	cf 93       	push	r28
 cce:	1f 93       	push	r17
 cd0:	0f 93       	push	r16
 cd2:	ff 92       	push	r15
 cd4:	c9 2f       	mov	r28, r25
 cd6:	dd 27       	eor	r29, r29
 cd8:	88 23       	and	r24, r24
 cda:	2a f0       	brmi	.+10     	; 0xce6 <log+0x28>
 cdc:	21 97       	sbiw	r28, 0x01	; 1
 cde:	66 0f       	add	r22, r22
 ce0:	77 1f       	adc	r23, r23
 ce2:	88 1f       	adc	r24, r24
 ce4:	da f7       	brpl	.-10     	; 0xcdc <log+0x1e>
 ce6:	20 e0       	ldi	r18, 0x00	; 0
 ce8:	30 e0       	ldi	r19, 0x00	; 0
 cea:	40 e8       	ldi	r20, 0x80	; 128
 cec:	5f eb       	ldi	r21, 0xBF	; 191
 cee:	9f e3       	ldi	r25, 0x3F	; 63
 cf0:	88 39       	cpi	r24, 0x98	; 152
 cf2:	20 f0       	brcs	.+8      	; 0xcfc <log+0x3e>
 cf4:	80 3e       	cpi	r24, 0xE0	; 224
 cf6:	38 f0       	brcs	.+14     	; 0xd06 <log+0x48>
 cf8:	21 96       	adiw	r28, 0x01	; 1
 cfa:	8f 77       	andi	r24, 0x7F	; 127
 cfc:	0e 94 b5 04 	call	0x96a	; 0x96a <__addsf3>
 d00:	e4 eb       	ldi	r30, 0xB4	; 180
 d02:	f0 e0       	ldi	r31, 0x00	; 0
 d04:	04 c0       	rjmp	.+8      	; 0xd0e <log+0x50>
 d06:	0e 94 b5 04 	call	0x96a	; 0x96a <__addsf3>
 d0a:	e1 ee       	ldi	r30, 0xE1	; 225
 d0c:	f0 e0       	ldi	r31, 0x00	; 0
 d0e:	0e 94 22 07 	call	0xe44	; 0xe44 <__fp_powser>
 d12:	8b 01       	movw	r16, r22
 d14:	be 01       	movw	r22, r28
 d16:	ec 01       	movw	r28, r24
 d18:	fb 2e       	mov	r15, r27
 d1a:	6f 57       	subi	r22, 0x7F	; 127
 d1c:	71 09       	sbc	r23, r1
 d1e:	75 95       	asr	r23
 d20:	77 1f       	adc	r23, r23
 d22:	88 0b       	sbc	r24, r24
 d24:	99 0b       	sbc	r25, r25
 d26:	0e 94 cb 05 	call	0xb96	; 0xb96 <__floatsisf>
 d2a:	28 e1       	ldi	r18, 0x18	; 24
 d2c:	32 e7       	ldi	r19, 0x72	; 114
 d2e:	41 e3       	ldi	r20, 0x31	; 49
 d30:	5f e3       	ldi	r21, 0x3F	; 63
 d32:	0e 94 ba 06 	call	0xd74	; 0xd74 <__mulsf3x>
 d36:	af 2d       	mov	r26, r15
 d38:	98 01       	movw	r18, r16
 d3a:	ae 01       	movw	r20, r28
 d3c:	ff 90       	pop	r15
 d3e:	0f 91       	pop	r16
 d40:	1f 91       	pop	r17
 d42:	cf 91       	pop	r28
 d44:	df 91       	pop	r29
 d46:	0e 94 cc 04 	call	0x998	; 0x998 <__addsf3x>
 d4a:	0c 94 1d 06 	jmp	0xc3a	; 0xc3a <__fp_round>

00000d4e <__mulsf3>:
 d4e:	0e 94 ba 06 	call	0xd74	; 0xd74 <__mulsf3x>
 d52:	0c 94 1d 06 	jmp	0xc3a	; 0xc3a <__fp_round>
 d56:	0e 94 0f 06 	call	0xc1e	; 0xc1e <__fp_pscA>
 d5a:	38 f0       	brcs	.+14     	; 0xd6a <__mulsf3+0x1c>
 d5c:	0e 94 16 06 	call	0xc2c	; 0xc2c <__fp_pscB>
 d60:	20 f0       	brcs	.+8      	; 0xd6a <__mulsf3+0x1c>
 d62:	95 23       	and	r25, r21
 d64:	11 f0       	breq	.+4      	; 0xd6a <__mulsf3+0x1c>
 d66:	0c 94 06 06 	jmp	0xc0c	; 0xc0c <__fp_inf>
 d6a:	0c 94 0c 06 	jmp	0xc18	; 0xc18 <__fp_nan>
 d6e:	11 24       	eor	r1, r1
 d70:	0c 94 51 06 	jmp	0xca2	; 0xca2 <__fp_szero>

00000d74 <__mulsf3x>:
 d74:	0e 94 2e 06 	call	0xc5c	; 0xc5c <__fp_split3>
 d78:	70 f3       	brcs	.-36     	; 0xd56 <__mulsf3+0x8>

00000d7a <__mulsf3_pse>:
 d7a:	95 9f       	mul	r25, r21
 d7c:	c1 f3       	breq	.-16     	; 0xd6e <__mulsf3+0x20>
 d7e:	95 0f       	add	r25, r21
 d80:	50 e0       	ldi	r21, 0x00	; 0
 d82:	55 1f       	adc	r21, r21
 d84:	62 9f       	mul	r22, r18
 d86:	f0 01       	movw	r30, r0
 d88:	72 9f       	mul	r23, r18
 d8a:	bb 27       	eor	r27, r27
 d8c:	f0 0d       	add	r31, r0
 d8e:	b1 1d       	adc	r27, r1
 d90:	63 9f       	mul	r22, r19
 d92:	aa 27       	eor	r26, r26
 d94:	f0 0d       	add	r31, r0
 d96:	b1 1d       	adc	r27, r1
 d98:	aa 1f       	adc	r26, r26
 d9a:	64 9f       	mul	r22, r20
 d9c:	66 27       	eor	r22, r22
 d9e:	b0 0d       	add	r27, r0
 da0:	a1 1d       	adc	r26, r1
 da2:	66 1f       	adc	r22, r22
 da4:	82 9f       	mul	r24, r18
 da6:	22 27       	eor	r18, r18
 da8:	b0 0d       	add	r27, r0
 daa:	a1 1d       	adc	r26, r1
 dac:	62 1f       	adc	r22, r18
 dae:	73 9f       	mul	r23, r19
 db0:	b0 0d       	add	r27, r0
 db2:	a1 1d       	adc	r26, r1
 db4:	62 1f       	adc	r22, r18
 db6:	83 9f       	mul	r24, r19
 db8:	a0 0d       	add	r26, r0
 dba:	61 1d       	adc	r22, r1
 dbc:	22 1f       	adc	r18, r18
 dbe:	74 9f       	mul	r23, r20
 dc0:	33 27       	eor	r19, r19
 dc2:	a0 0d       	add	r26, r0
 dc4:	61 1d       	adc	r22, r1
 dc6:	23 1f       	adc	r18, r19
 dc8:	84 9f       	mul	r24, r20
 dca:	60 0d       	add	r22, r0
 dcc:	21 1d       	adc	r18, r1
 dce:	82 2f       	mov	r24, r18
 dd0:	76 2f       	mov	r23, r22
 dd2:	6a 2f       	mov	r22, r26
 dd4:	11 24       	eor	r1, r1
 dd6:	9f 57       	subi	r25, 0x7F	; 127
 dd8:	50 40       	sbci	r21, 0x00	; 0
 dda:	9a f0       	brmi	.+38     	; 0xe02 <__mulsf3_pse+0x88>
 ddc:	f1 f0       	breq	.+60     	; 0xe1a <__mulsf3_pse+0xa0>
 dde:	88 23       	and	r24, r24
 de0:	4a f0       	brmi	.+18     	; 0xdf4 <__mulsf3_pse+0x7a>
 de2:	ee 0f       	add	r30, r30
 de4:	ff 1f       	adc	r31, r31
 de6:	bb 1f       	adc	r27, r27
 de8:	66 1f       	adc	r22, r22
 dea:	77 1f       	adc	r23, r23
 dec:	88 1f       	adc	r24, r24
 dee:	91 50       	subi	r25, 0x01	; 1
 df0:	50 40       	sbci	r21, 0x00	; 0
 df2:	a9 f7       	brne	.-22     	; 0xdde <__mulsf3_pse+0x64>
 df4:	9e 3f       	cpi	r25, 0xFE	; 254
 df6:	51 05       	cpc	r21, r1
 df8:	80 f0       	brcs	.+32     	; 0xe1a <__mulsf3_pse+0xa0>
 dfa:	0c 94 06 06 	jmp	0xc0c	; 0xc0c <__fp_inf>
 dfe:	0c 94 51 06 	jmp	0xca2	; 0xca2 <__fp_szero>
 e02:	5f 3f       	cpi	r21, 0xFF	; 255
 e04:	e4 f3       	brlt	.-8      	; 0xdfe <__mulsf3_pse+0x84>
 e06:	98 3e       	cpi	r25, 0xE8	; 232
 e08:	d4 f3       	brlt	.-12     	; 0xdfe <__mulsf3_pse+0x84>
 e0a:	86 95       	lsr	r24
 e0c:	77 95       	ror	r23
 e0e:	67 95       	ror	r22
 e10:	b7 95       	ror	r27
 e12:	f7 95       	ror	r31
 e14:	e7 95       	ror	r30
 e16:	9f 5f       	subi	r25, 0xFF	; 255
 e18:	c1 f7       	brne	.-16     	; 0xe0a <__mulsf3_pse+0x90>
 e1a:	fe 2b       	or	r31, r30
 e1c:	88 0f       	add	r24, r24
 e1e:	91 1d       	adc	r25, r1
 e20:	96 95       	lsr	r25
 e22:	87 95       	ror	r24
 e24:	97 f9       	bld	r25, 7
 e26:	08 95       	ret

00000e28 <__fp_mpack>:
 e28:	9f 3f       	cpi	r25, 0xFF	; 255
 e2a:	31 f0       	breq	.+12     	; 0xe38 <__fp_mpack_finite+0xc>

00000e2c <__fp_mpack_finite>:
 e2c:	91 50       	subi	r25, 0x01	; 1
 e2e:	20 f4       	brcc	.+8      	; 0xe38 <__fp_mpack_finite+0xc>
 e30:	87 95       	ror	r24
 e32:	77 95       	ror	r23
 e34:	67 95       	ror	r22
 e36:	b7 95       	ror	r27
 e38:	88 0f       	add	r24, r24
 e3a:	91 1d       	adc	r25, r1
 e3c:	96 95       	lsr	r25
 e3e:	87 95       	ror	r24
 e40:	97 f9       	bld	r25, 7
 e42:	08 95       	ret

00000e44 <__fp_powser>:
 e44:	df 93       	push	r29
 e46:	cf 93       	push	r28
 e48:	1f 93       	push	r17
 e4a:	0f 93       	push	r16
 e4c:	ff 92       	push	r15
 e4e:	ef 92       	push	r14
 e50:	df 92       	push	r13
 e52:	7b 01       	movw	r14, r22
 e54:	8c 01       	movw	r16, r24
 e56:	68 94       	set
 e58:	06 c0       	rjmp	.+12     	; 0xe66 <__fp_powser+0x22>
 e5a:	da 2e       	mov	r13, r26
 e5c:	ef 01       	movw	r28, r30
 e5e:	0e 94 ba 06 	call	0xd74	; 0xd74 <__mulsf3x>
 e62:	fe 01       	movw	r30, r28
 e64:	e8 94       	clt
 e66:	a5 91       	lpm	r26, Z+
 e68:	25 91       	lpm	r18, Z+
 e6a:	35 91       	lpm	r19, Z+
 e6c:	45 91       	lpm	r20, Z+
 e6e:	55 91       	lpm	r21, Z+
 e70:	a6 f3       	brts	.-24     	; 0xe5a <__fp_powser+0x16>
 e72:	ef 01       	movw	r28, r30
 e74:	0e 94 cc 04 	call	0x998	; 0x998 <__addsf3x>
 e78:	fe 01       	movw	r30, r28
 e7a:	97 01       	movw	r18, r14
 e7c:	a8 01       	movw	r20, r16
 e7e:	da 94       	dec	r13
 e80:	69 f7       	brne	.-38     	; 0xe5c <__fp_powser+0x18>
 e82:	df 90       	pop	r13
 e84:	ef 90       	pop	r14
 e86:	ff 90       	pop	r15
 e88:	0f 91       	pop	r16
 e8a:	1f 91       	pop	r17
 e8c:	cf 91       	pop	r28
 e8e:	df 91       	pop	r29
 e90:	08 95       	ret

00000e92 <__divmodhi4>:
 e92:	97 fb       	bst	r25, 7
 e94:	07 2e       	mov	r0, r23
 e96:	16 f4       	brtc	.+4      	; 0xe9c <__divmodhi4+0xa>
 e98:	00 94       	com	r0
 e9a:	07 d0       	rcall	.+14     	; 0xeaa <__divmodhi4_neg1>
 e9c:	77 fd       	sbrc	r23, 7
 e9e:	09 d0       	rcall	.+18     	; 0xeb2 <__divmodhi4_neg2>
 ea0:	0e 94 5d 07 	call	0xeba	; 0xeba <__udivmodhi4>
 ea4:	07 fc       	sbrc	r0, 7
 ea6:	05 d0       	rcall	.+10     	; 0xeb2 <__divmodhi4_neg2>
 ea8:	3e f4       	brtc	.+14     	; 0xeb8 <__divmodhi4_exit>

00000eaa <__divmodhi4_neg1>:
 eaa:	90 95       	com	r25
 eac:	81 95       	neg	r24
 eae:	9f 4f       	sbci	r25, 0xFF	; 255
 eb0:	08 95       	ret

00000eb2 <__divmodhi4_neg2>:
 eb2:	70 95       	com	r23
 eb4:	61 95       	neg	r22
 eb6:	7f 4f       	sbci	r23, 0xFF	; 255

00000eb8 <__divmodhi4_exit>:
 eb8:	08 95       	ret

00000eba <__udivmodhi4>:
 eba:	aa 1b       	sub	r26, r26
 ebc:	bb 1b       	sub	r27, r27
 ebe:	51 e1       	ldi	r21, 0x11	; 17
 ec0:	07 c0       	rjmp	.+14     	; 0xed0 <__udivmodhi4_ep>

00000ec2 <__udivmodhi4_loop>:
 ec2:	aa 1f       	adc	r26, r26
 ec4:	bb 1f       	adc	r27, r27
 ec6:	a6 17       	cp	r26, r22
 ec8:	b7 07       	cpc	r27, r23
 eca:	10 f0       	brcs	.+4      	; 0xed0 <__udivmodhi4_ep>
 ecc:	a6 1b       	sub	r26, r22
 ece:	b7 0b       	sbc	r27, r23

00000ed0 <__udivmodhi4_ep>:
 ed0:	88 1f       	adc	r24, r24
 ed2:	99 1f       	adc	r25, r25
 ed4:	5a 95       	dec	r21
 ed6:	a9 f7       	brne	.-22     	; 0xec2 <__udivmodhi4_loop>
 ed8:	80 95       	com	r24
 eda:	90 95       	com	r25
 edc:	bc 01       	movw	r22, r24
 ede:	cd 01       	movw	r24, r26
 ee0:	08 95       	ret

00000ee2 <_exit>:
 ee2:	f8 94       	cli

00000ee4 <__stop_program>:
 ee4:	ff cf       	rjmp	.-2      	; 0xee4 <__stop_program>
