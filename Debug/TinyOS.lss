
TinyOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000262  00800100  00000efa  00000f8e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000efa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000015  00800362  00800362  000011f0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000011f0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001220  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000a8  00000000  00000000  00001260  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001471  00000000  00000000  00001308  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000aa9  00000000  00000000  00002779  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000cce  00000000  00000000  00003222  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000198  00000000  00000000  00003ef0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005eb  00000000  00000000  00004088  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000003c1  00000000  00000000  00004673  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000078  00000000  00000000  00004a34  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 87 00 	jmp	0x10e	; 0x10e <__ctors_end>
   4:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
   8:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
   c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  10:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  14:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  18:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  1c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  20:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  24:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  28:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  2c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  30:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  34:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  38:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  3c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  40:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  44:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  48:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  4c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  50:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  54:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  58:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  5c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  60:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  64:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  68:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  6c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  70:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  74:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  78:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  7c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  80:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  84:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  88:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  8c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  90:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  94:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  98:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  9c:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  a0:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  a4:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  a8:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  ac:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  b0:	0c 94 a4 00 	jmp	0x148	; 0x148 <__bad_interrupt>
  b4:	08 00       	.word	0x0008	; ????
  b6:	00 00       	nop
  b8:	be 92       	st	-X, r11
  ba:	24 49       	sbci	r18, 0x94	; 148
  bc:	12 3e       	cpi	r17, 0xE2	; 226
  be:	ab aa       	std	Y+51, r10	; 0x33
  c0:	aa 2a       	or	r10, r26
  c2:	be cd       	rjmp	.-1156   	; 0xfffffc40 <__eeprom_end+0xff7efc40>
  c4:	cc cc       	rjmp	.-1640   	; 0xfffffa5e <__eeprom_end+0xff7efa5e>
  c6:	4c 3e       	cpi	r20, 0xEC	; 236
  c8:	00 00       	nop
  ca:	00 80       	ld	r0, Z
  cc:	be ab       	std	Y+54, r27	; 0x36
  ce:	aa aa       	std	Y+50, r10	; 0x32
  d0:	aa 3e       	cpi	r26, 0xEA	; 234
  d2:	00 00       	nop
  d4:	00 00       	nop
  d6:	bf 00       	.word	0x00bf	; ????
  d8:	00 00       	nop
  da:	80 3f       	cpi	r24, 0xF0	; 240
  dc:	00 00       	nop
  de:	00 00       	nop
  e0:	00 08       	sbc	r0, r0
  e2:	41 78       	andi	r20, 0x81	; 129
  e4:	d3 bb       	out	0x13, r29	; 19
  e6:	43 87       	std	Z+11, r20	; 0x0b
  e8:	d1 13       	cpse	r29, r17
  ea:	3d 19       	sub	r19, r13
  ec:	0e 3c       	cpi	r16, 0xCE	; 206
  ee:	c3 bd       	out	0x23, r28	; 35
  f0:	42 82       	std	Z+2, r4	; 0x02
  f2:	ad 2b       	or	r26, r29
  f4:	3e 68       	ori	r19, 0x8E	; 142
  f6:	ec 82       	std	Y+4, r14	; 0x04
  f8:	76 be       	out	0x36, r7	; 54
  fa:	d9 8f       	std	Y+25, r29	; 0x19
  fc:	e1 a9       	ldd	r30, Z+49	; 0x31
  fe:	3e 4c       	sbci	r19, 0xCE	; 206
 100:	80 ef       	ldi	r24, 0xF0	; 240
 102:	ff be       	out	0x3f, r15	; 63
 104:	01 c4       	rjmp	.+2050   	; 0x908 <__stack+0x9>
 106:	ff 7f       	andi	r31, 0xFF	; 255
 108:	3f 00       	.word	0x003f	; ????
 10a:	00 00       	nop
	...

0000010e <__ctors_end>:
 10e:	11 24       	eor	r1, r1
 110:	1f be       	out	0x3f, r1	; 63
 112:	cf ef       	ldi	r28, 0xFF	; 255
 114:	d8 e0       	ldi	r29, 0x08	; 8
 116:	de bf       	out	0x3e, r29	; 62
 118:	cd bf       	out	0x3d, r28	; 61

0000011a <__do_copy_data>:
 11a:	13 e0       	ldi	r17, 0x03	; 3
 11c:	a0 e0       	ldi	r26, 0x00	; 0
 11e:	b1 e0       	ldi	r27, 0x01	; 1
 120:	ea ef       	ldi	r30, 0xFA	; 250
 122:	fe e0       	ldi	r31, 0x0E	; 14
 124:	02 c0       	rjmp	.+4      	; 0x12a <__do_copy_data+0x10>
 126:	05 90       	lpm	r0, Z+
 128:	0d 92       	st	X+, r0
 12a:	a2 36       	cpi	r26, 0x62	; 98
 12c:	b1 07       	cpc	r27, r17
 12e:	d9 f7       	brne	.-10     	; 0x126 <__do_copy_data+0xc>

00000130 <__do_clear_bss>:
 130:	23 e0       	ldi	r18, 0x03	; 3
 132:	a2 e6       	ldi	r26, 0x62	; 98
 134:	b3 e0       	ldi	r27, 0x03	; 3
 136:	01 c0       	rjmp	.+2      	; 0x13a <.do_clear_bss_start>

00000138 <.do_clear_bss_loop>:
 138:	1d 92       	st	X+, r1

0000013a <.do_clear_bss_start>:
 13a:	a7 37       	cpi	r26, 0x77	; 119
 13c:	b2 07       	cpc	r27, r18
 13e:	e1 f7       	brne	.-8      	; 0x138 <.do_clear_bss_loop>
 140:	0e 94 b7 04 	call	0x96e	; 0x96e <main>
 144:	0c 94 7b 07 	jmp	0xef6	; 0xef6 <_exit>

00000148 <__bad_interrupt>:
 148:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000014c <Mega328P_Init>:
.section ".text"			//student comment here

//Mo
.global Mega328P_Init
Mega328P_Init:
		ldi	r16,0x07		;PB0(R*W),PB1(RS),PB2(E) as fixed outputs
 14c:	07 e0       	ldi	r16, 0x07	; 7
		out	DDRB,r16		//student comment here
 14e:	04 b9       	out	0x04, r16	; 4
		ldi	r16,0			//student comment here
 150:	00 e0       	ldi	r16, 0x00	; 0
		out	PORTB,r16		//student comment here
 152:	05 b9       	out	0x05, r16	; 5
		out	U2X0,r16		;initialize UART, 8bits, no parity, 1 stop, 9600
 154:	01 b9       	out	0x01, r16	; 1
		ldi	r17,0x0			//student comment here
 156:	10 e0       	ldi	r17, 0x00	; 0
		ldi	r16,0x67		//student comment here
 158:	07 e6       	ldi	r16, 0x67	; 103
		sts	UBRR0H,r17		//student comment here
 15a:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		sts	UBRR0L,r16		//student comment here
 15e:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		ldi	r16,24			//student comment here
 162:	08 e1       	ldi	r16, 0x18	; 24
		sts	UCSR0B,r16		//student comment here
 164:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		ldi	r16,6			//student comment here
 168:	06 e0       	ldi	r16, 0x06	; 6
		sts	UCSR0C,r16		//student comment here
 16a:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		ldi r16,0x87		//initialize ADC
 16e:	07 e8       	ldi	r16, 0x87	; 135
		sts	ADCSRA,r16		//student comment here
 170:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		ldi r16,0x40		//student comment here
 174:	00 e4       	ldi	r16, 0x40	; 64
		sts ADMUX,r16		//student comment here
 176:	00 93 7c 00 	sts	0x007C, r16	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
		ldi r16,0			//student comment here
 17a:	00 e0       	ldi	r16, 0x00	; 0
		sts ADCSRB,r16		//student comment here
 17c:	00 93 7b 00 	sts	0x007B, r16	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
		ldi r16,0xFE		//student comment here
 180:	0e ef       	ldi	r16, 0xFE	; 254
		sts DIDR0,r16		//student comment here
 182:	00 93 7e 00 	sts	0x007E, r16	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
		ldi r16,0xFF		//student comment here
 186:	0f ef       	ldi	r16, 0xFF	; 255
		sts DIDR1,r16		//student comment here
 188:	00 93 7f 00 	sts	0x007F, r16	; 0x80007f <__TEXT_REGION_LENGTH__+0x7e007f>
		ret					//student comment here
 18c:	08 95       	ret

0000018e <LCD_Write_Command>:
	
//Kaden
.global LCD_Write_Command
LCD_Write_Command:
	call	UART_Off		//student comment here
 18e:	0e 94 04 01 	call	0x208	; 0x208 <UART_Off>
	ldi		r16,0xFF		;PD0 - PD7 as outputs
 192:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		//student comment here
 194:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		//student comment here
 196:	00 91 64 03 	lds	r16, 0x0364	; 0x800364 <DATA>
	out		PORTD,r16		//student comment here
 19a:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,4			//student comment here
 19c:	04 e0       	ldi	r16, 0x04	; 4
	out		PORTB,r16		//student comment here
 19e:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 1a0:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
	ldi		r16,0			//student comment here
 1a4:	00 e0       	ldi	r16, 0x00	; 0
	out		PORTB,r16		//student comment here
 1a6:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 1a8:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
	call	UART_On			//student comment here
 1ac:	0e 94 fe 00 	call	0x1fc	; 0x1fc <UART_On>
	ret						//student comment here
 1b0:	08 95       	ret

000001b2 <LCD_Delay>:

.global LCD_Delay
LCD_Delay:
	ldi		r16,0xFA		//student comment here
 1b2:	0a ef       	ldi	r16, 0xFA	; 250

000001b4 <D0>:
D0:	ldi		r17,0xFF		//student comment here
 1b4:	1f ef       	ldi	r17, 0xFF	; 255

000001b6 <D1>:
D1:	dec		r17				//student comment here
 1b6:	1a 95       	dec	r17
	brne	D1				//student comment here
 1b8:	f1 f7       	brne	.-4      	; 0x1b6 <D1>
	dec		r16				//student comment here
 1ba:	0a 95       	dec	r16
	brne	D0				//student comment here
 1bc:	d9 f7       	brne	.-10     	; 0x1b4 <D0>
	ret						//student comment here
 1be:	08 95       	ret

000001c0 <LCD_Write_Data>:

.global LCD_Write_Data
LCD_Write_Data:
	call	UART_Off		//student comment here
 1c0:	0e 94 04 01 	call	0x208	; 0x208 <UART_Off>
	ldi		r16,0xFF		//student comment here
 1c4:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		//student comment here
 1c6:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		//student comment here
 1c8:	00 91 64 03 	lds	r16, 0x0364	; 0x800364 <DATA>
	out		PORTD,r16		//student comment here
 1cc:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,6			//student comment here
 1ce:	06 e0       	ldi	r16, 0x06	; 6
	out		PORTB,r16		//student comment here
 1d0:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 1d2:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
	ldi		r16,0			//student comment here
 1d6:	00 e0       	ldi	r16, 0x00	; 0
	out		PORTB,r16		//student comment here
 1d8:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 1da:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
	call	UART_On			//student comment here
 1de:	0e 94 fe 00 	call	0x1fc	; 0x1fc <UART_On>
	ret						//student comment here
 1e2:	08 95       	ret

000001e4 <LCD_Read_Data>:

.global LCD_Read_Data
LCD_Read_Data:
	call	UART_Off		//student comment here
 1e4:	0e 94 04 01 	call	0x208	; 0x208 <UART_Off>
	ldi		r16,0x00		//student comment here
 1e8:	00 e0       	ldi	r16, 0x00	; 0
	out		DDRD,r16		//student comment here
 1ea:	0a b9       	out	0x0a, r16	; 10
	out		PORTB,4			//student comment here
 1ec:	45 b8       	out	0x05, r4	; 5
	in		r16,PORTD		//student comment here
 1ee:	0b b1       	in	r16, 0x0b	; 11
	sts		DATA,r16		//student comment here
 1f0:	00 93 64 03 	sts	0x0364, r16	; 0x800364 <DATA>
	out		PORTB,0			//student comment here
 1f4:	05 b8       	out	0x05, r0	; 5
	call	UART_On			//student comment here
 1f6:	0e 94 fe 00 	call	0x1fc	; 0x1fc <UART_On>
	ret						//student comment here
 1fa:	08 95       	ret

000001fc <UART_On>:

//Austin
.global UART_On
UART_On:
	ldi		r16,2				//student comment here
 1fc:	02 e0       	ldi	r16, 0x02	; 2
	out		DDRD,r16			//set data direction register to 00000010
 1fe:	0a b9       	out	0x0a, r16	; 10
	ldi		r16,24				
 200:	08 e1       	ldi	r16, 0x18	; 24
	sts		UCSR0B,r16			//Enables UART reciever and transmitter
 202:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret						
 206:	08 95       	ret

00000208 <UART_Off>:

.global UART_Off
UART_Off:
	ldi	r16,0					
 208:	00 e0       	ldi	r16, 0x00	; 0
	sts UCSR0B,r16				//disables reciever and transmitter
 20a:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret					
 20e:	08 95       	ret

00000210 <UART_Clear>:

.global UART_Clear
UART_Clear:
	lds		r16,UCSR0A			//recives register status from UART
 210:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r16,RXC0			//skips next line if data was recieved
 214:	07 ff       	sbrs	r16, 7
	ret							
 216:	08 95       	ret
	lds		r16,UDR0			//puts data into register, clears memory address
 218:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	rjmp	UART_Clear			//jumps back to begining
 21c:	f9 cf       	rjmp	.-14     	; 0x210 <UART_Clear>

0000021e <UART_Get>:

.global UART_Get
UART_Get:
	lds		r16,UCSR0A			//recives register status from UART
 21e:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r16,RXC0			//skips next line if data was recieved
 222:	07 ff       	sbrs	r16, 7
	rjmp	UART_Get			//jumps back if data was not recieved
 224:	fc cf       	rjmp	.-8      	; 0x21e <UART_Get>
	lds		r16,UDR0			//recives data 
 226:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	sts		ASCII,r16			//puts data into ASCII
 22a:	00 93 6a 03 	sts	0x036A, r16	; 0x80036a <ASCII>
	ret							
 22e:	08 95       	ret

00000230 <UART_Poll>:

.global UART_Poll
UART_Poll:
	lds		r18,UCSR0A			//recives register status from UART
 230:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r18,RXC0			//skips next line if data was recieved
 234:	27 ff       	sbrs	r18, 7
	ret
 236:	08 95       	ret
	lds		r18,UDR0			//recives data 
 238:	20 91 c6 00 	lds	r18, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	sts		ASCII,r18			//puts data into ASCII
 23c:	20 93 6a 03 	sts	0x036A, r18	; 0x80036a <ASCII>
	ret	
 240:	08 95       	ret

00000242 <UART_Put>:
	
.global UART_Put
UART_Put:
	lds		r17,UCSR0A			//recives register status from UART
 242:	10 91 c0 00 	lds	r17, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r17,UDRE0			//skips next line if UART not in transmitting mode
 246:	15 ff       	sbrs	r17, 5
	rjmp	UART_Put
 248:	fc cf       	rjmp	.-8      	; 0x242 <UART_Put>
	lds		r16,ASCII			//recieves put data
 24a:	00 91 6a 03 	lds	r16, 0x036A	; 0x80036a <ASCII>
	sts		UDR0,r16			//outputs data
 24e:	00 93 c6 00 	sts	0x00C6, r16	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	ret	
 252:	08 95       	ret

00000254 <ADC_Get>:

//Mason
.global ADC_Get
ADC_Get:
	ldi		r16,0xC7			//Sets 0xC7 to register 16 to be loaded into address ADCSRA  
 254:	07 ec       	ldi	r16, 0xC7	; 199
	sts		ADCSRA,r16			//r16 is stored to address ADSRA for use in loop
 256:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>

0000025a <A2V1>:
A2V1:
	lds		r16,ADCSRA			//loads value stored in ADSRA to r16 a reset of the value
 25a:	00 91 7a 00 	lds	r16, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
	sbrc	r16,ADSC			//If the bit in r16 is cleared skips the next instruction, this will end the loop
 25e:	06 fd       	sbrc	r16, 6
	rjmp 	A2V1				//Jumps back to A2V1 to create loop 
 260:	fc cf       	rjmp	.-8      	; 0x25a <A2V1>
	lds		r16,ADCL			//The low value of the ADC port is stored in r16
 262:	00 91 78 00 	lds	r16, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
	sts		LADC,r16			//Then the value of ADCL is loaded into a global address to be used in C program
 266:	00 93 72 03 	sts	0x0372, r16	; 0x800372 <LADC>
	lds		r16,ADCH			//The high value of the ADC port is stored in r16
 26a:	00 91 79 00 	lds	r16, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
	sts		HADC,r16			//Then stored to the global address HADC to be used in C program
 26e:	00 93 65 03 	sts	0x0365, r16	; 0x800365 <HADC>
	ret							//Returns to the section where call was made
 272:	08 95       	ret

00000274 <EEPROM_Write>:

.global EEPROM_Write
EEPROM_Write:      
	sbic    EECR,EEPE
 274:	f9 99       	sbic	0x1f, 1	; 31
	rjmp    EEPROM_Write		; Wait for completion of previous write
 276:	fe cf       	rjmp	.-4      	; 0x274 <EEPROM_Write>
	lds		r18,EELOCH			; Set up address (r18:r17) in address register
 278:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__TEXT_REGION_LENGTH__+0x7e0000>
	lds		r17,EELOCL 
 27c:	10 91 00 00 	lds	r17, 0x0000	; 0x800000 <__TEXT_REGION_LENGTH__+0x7e0000>
	ldi		r16,'F'				; Set up data in r16    
 280:	06 e4       	ldi	r16, 0x46	; 70
	out     EEARH, r18      
 282:	22 bd       	out	0x22, r18	; 34
	out     EEARL, r17			      
 284:	11 bd       	out	0x21, r17	; 33
	out     EEDR,r16			; Write data (r16) to Data Register  
 286:	00 bd       	out	0x20, r16	; 32
	sbi     EECR,EEMPE			; Write logical one to EEMPE
 288:	fa 9a       	sbi	0x1f, 2	; 31
	sbi     EECR,EEPE			; Start eeprom write by setting EEPE
 28a:	f9 9a       	sbi	0x1f, 1	; 31
	ret 
 28c:	08 95       	ret

0000028e <EEPROM_Read>:

.global EEPROM_Read
EEPROM_Read:					    
	sbic    EECR,EEPE    
 28e:	f9 99       	sbic	0x1f, 1	; 31
	rjmp    EEPROM_Read			; Wait for completion of previous write
 290:	fe cf       	rjmp	.-4      	; 0x28e <EEPROM_Read>
	lds		r18,EELOCH			; Set up address (r18:r17) in EEPROM address register
 292:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__TEXT_REGION_LENGTH__+0x7e0000>
	lds		r17,EELOCL
 296:	10 91 00 00 	lds	r17, 0x0000	; 0x800000 <__TEXT_REGION_LENGTH__+0x7e0000>
	ldi		r16,0x00   
 29a:	00 e0       	ldi	r16, 0x00	; 0
	out     EEARH, r18   
 29c:	22 bd       	out	0x22, r18	; 34
	out     EEARL, r17		   
 29e:	11 bd       	out	0x21, r17	; 33
	sbi     EECR,EERE			; Start eeprom read by writing EERE
 2a0:	f8 9a       	sbi	0x1f, 0	; 31
	in      r16,EEDR			; Read data from Data Register
 2a2:	00 b5       	in	r16, 0x20	; 32
	sts		ASCII,r16  
 2a4:	00 93 6a 03 	sts	0x036A, r16	; 0x80036a <ASCII>
	ret
 2a8:	08 95       	ret

000002aa <EEMEMORYH>:

	
.global EEMEMORYH
EEMEMORYH:
		lds	r16, EELOCH
 2aa:	00 91 00 00 	lds	r16, 0x0000	; 0x800000 <__TEXT_REGION_LENGTH__+0x7e0000>
		lds	r17, DATA
 2ae:	10 91 64 03 	lds	r17, 0x0364	; 0x800364 <DATA>
		add	r16, r17
 2b2:	01 0f       	add	r16, r17
		sts	EELOCH, r16
 2b4:	00 93 00 00 	sts	0x0000, r16	; 0x800000 <__TEXT_REGION_LENGTH__+0x7e0000>
		ret
 2b8:	08 95       	ret

000002ba <EEMEMORYL>:

.global EEMEMORYL
EEMEMORYL:
		lds	r16, EELOCL
 2ba:	00 91 00 00 	lds	r16, 0x0000	; 0x800000 <__TEXT_REGION_LENGTH__+0x7e0000>
		lds	r17, DATA
 2be:	10 91 64 03 	lds	r17, 0x0364	; 0x800364 <DATA>
		add	r16, r17
 2c2:	01 0f       	add	r16, r17
		sts	EELOCL, r16
 2c4:	00 93 00 00 	sts	0x0000, r16	; 0x800000 <__TEXT_REGION_LENGTH__+0x7e0000>
		ret
 2c8:	08 95       	ret

000002ca <EEMEMORYR>:
			
.global EEMEMORYR
EEMEMORYR:
		ldi	r16, 0
 2ca:	00 e0       	ldi	r16, 0x00	; 0
		sts	EELOCH, r16
 2cc:	00 93 00 00 	sts	0x0000, r16	; 0x800000 <__TEXT_REGION_LENGTH__+0x7e0000>
		sts EELOCL, r16
 2d0:	00 93 00 00 	sts	0x0000, r16	; 0x800000 <__TEXT_REGION_LENGTH__+0x7e0000>
		ret
 2d4:	08 95       	ret

000002d6 <SETC>:

.global SETC
SETC: 
	lds		r16, UCSR0C
 2d6:	00 91 c2 00 	lds	r16, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
	lds		r17, USARTDATA
 2da:	10 91 62 03 	lds	r17, 0x0362	; 0x800362 <__data_end>
	or		r16, r17
 2de:	01 2b       	or	r16, r17
	sts		UCSR0C, r16
 2e0:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
	ret		
 2e4:	08 95       	ret

000002e6 <CLEARC>:

.global CLEARC
CLEARC: 
	lds		r16, UCSR0C
 2e6:	00 91 c2 00 	lds	r16, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
	ldi		r17, 0xFF
 2ea:	1f ef       	ldi	r17, 0xFF	; 255
	lds		r18, USARTDATA
 2ec:	20 91 62 03 	lds	r18, 0x0362	; 0x800362 <__data_end>
	sub		r17, r18
 2f0:	12 1b       	sub	r17, r18
	and		r16, r17
 2f2:	01 23       	and	r16, r17
	sts		UCSR0C, r16
 2f4:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
	ret
 2f8:	08 95       	ret

000002fa <SETB>:

.global SETB
SETB: 
	lds		r16, UCSR0B
 2fa:	00 91 c1 00 	lds	r16, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ldi		r17, 0xFF
 2fe:	1f ef       	ldi	r17, 0xFF	; 255
	lds		r18, USARTDATA
 300:	20 91 62 03 	lds	r18, 0x0362	; 0x800362 <__data_end>
	sub		r17, r18
 304:	12 1b       	sub	r17, r18
	and		r16, r17
 306:	01 23       	and	r16, r17
	sts		UCSR0B, r16
 308:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret
 30c:	08 95       	ret

0000030e <CLEARB>:
	
.global CLEARB
CLEARB:
	lds		r16, UCSR0B
 30e:	00 91 c1 00 	lds	r16, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	lds		r17, USARTDATA
 312:	10 91 62 03 	lds	r17, 0x0362	; 0x800362 <__data_end>
	or		r16, r17
 316:	01 2b       	or	r16, r17
	sts		UCSR0B, r16
 318:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret
 31c:	08 95       	ret

0000031e <SETBAUD>:

.global SETBAUD
SETBAUD:
	lds		r16, BAUDL
 31e:	00 91 75 03 	lds	r16, 0x0375	; 0x800375 <BAUDL>
	lds		r17, BAUDH
 322:	10 91 66 03 	lds	r17, 0x0366	; 0x800366 <BAUDH>
	sts		UBRR0L,r16
 326:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	sts		UBRR0H,r17
 32a:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
	ret
 32e:	08 95       	ret

00000330 <UART_Puts>:
char HADC;						//shared ADC variable with Assembly
char LADC;						//shared ADC variable with Assembly
char temp[5];					//string buffer for ADC output

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
 330:	cf 93       	push	r28
 332:	df 93       	push	r29
 334:	ec 01       	movw	r28, r24
	while (*str)
 336:	98 81       	ld	r25, Y
 338:	99 23       	and	r25, r25
 33a:	41 f0       	breq	.+16     	; 0x34c <UART_Puts+0x1c>
 33c:	21 96       	adiw	r28, 0x01	; 1
	{
		ASCII = *str++;
 33e:	90 93 6a 03 	sts	0x036A, r25	; 0x80036a <ASCII>
		UART_Put();
 342:	0e 94 21 01 	call	0x242	; 0x242 <UART_Put>
char LADC;						//shared ADC variable with Assembly
char temp[5];					//string buffer for ADC output

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
	while (*str)
 346:	99 91       	ld	r25, Y+
 348:	91 11       	cpse	r25, r1
 34a:	f9 cf       	rjmp	.-14     	; 0x33e <UART_Puts+0xe>
	{
		ASCII = *str++;
		UART_Put();
	}
}
 34c:	df 91       	pop	r29
 34e:	cf 91       	pop	r28
 350:	08 95       	ret

00000352 <LCD_Puts>:

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
 352:	cf 93       	push	r28
 354:	df 93       	push	r29
 356:	ec 01       	movw	r28, r24
	while (*str)
 358:	98 81       	ld	r25, Y
 35a:	99 23       	and	r25, r25
 35c:	41 f0       	breq	.+16     	; 0x36e <LCD_Puts+0x1c>
 35e:	21 96       	adiw	r28, 0x01	; 1
	{
		DATA = *str++;
 360:	90 93 64 03 	sts	0x0364, r25	; 0x800364 <DATA>
		LCD_Write_Data();
 364:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <LCD_Write_Data>
	}
}

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
	while (*str)
 368:	99 91       	ld	r25, Y+
 36a:	91 11       	cpse	r25, r1
 36c:	f9 cf       	rjmp	.-14     	; 0x360 <LCD_Puts+0xe>
	{
		DATA = *str++;
		LCD_Write_Data();
	}
}
 36e:	df 91       	pop	r29
 370:	cf 91       	pop	r28
 372:	08 95       	ret

00000374 <Banner>:

void Banner(void)				//Display Tiny OS Banner on Terminal
{
	UART_Puts(MS1);
 374:	84 e4       	ldi	r24, 0x44	; 68
 376:	93 e0       	ldi	r25, 0x03	; 3
 378:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
	UART_Puts(MS2);
 37c:	8d e0       	ldi	r24, 0x0D	; 13
 37e:	93 e0       	ldi	r25, 0x03	; 3
 380:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
	UART_Puts(MS4);
 384:	88 ed       	ldi	r24, 0xD8	; 216
 386:	92 e0       	ldi	r25, 0x02	; 2
 388:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
 38c:	08 95       	ret

0000038e <HELP>:
}

void HELP(void)						//Display available Tiny OS Commands on Terminal
{
	UART_Puts(MS3);
 38e:	82 ee       	ldi	r24, 0xE2	; 226
 390:	92 e0       	ldi	r25, 0x02	; 2
 392:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
 396:	08 95       	ret

00000398 <LCD>:
}

void LCD(void)						//Lite LCD demo
{	
 398:	ff 92       	push	r15
 39a:	0f 93       	push	r16
 39c:	1f 93       	push	r17
 39e:	cf 93       	push	r28
 3a0:	df 93       	push	r29
	LCD_Write_Command();
 3a2:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x08;					//Turns display and cursor off
 3a6:	88 e0       	ldi	r24, 0x08	; 8
 3a8:	80 93 64 03 	sts	0x0364, r24	; 0x800364 <DATA>
	LCD_Write_Command();
 3ac:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x02;					//Returns home
 3b0:	82 e0       	ldi	r24, 0x02	; 2
 3b2:	80 93 64 03 	sts	0x0364, r24	; 0x800364 <DATA>
	LCD_Write_Command();
 3b6:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x06;					//Shifts Cursor to the right
 3ba:	86 e0       	ldi	r24, 0x06	; 6
 3bc:	80 93 64 03 	sts	0x0364, r24	; 0x800364 <DATA>
	LCD_Write_Command();
 3c0:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x0f;					//Display on cursor blinking
 3c4:	8f e0       	ldi	r24, 0x0F	; 15
 3c6:	80 93 64 03 	sts	0x0364, r24	; 0x800364 <DATA>
	LCD_Write_Command();
 3ca:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	DATA = 0x0c;					//Display on cursor off
 3ce:	8c e0       	ldi	r24, 0x0C	; 12
 3d0:	80 93 64 03 	sts	0x0364, r24	; 0x800364 <DATA>
	LCD_Write_Command();
 3d4:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
	
	LCD_Puts(output);				//Puts the output sting onto the LCD
 3d8:	80 e0       	ldi	r24, 0x00	; 0
 3da:	91 e0       	ldi	r25, 0x01	; 1
 3dc:	0e 94 a9 01 	call	0x352	; 0x352 <LCD_Puts>
 3e0:	00 e1       	ldi	r16, 0x10	; 16
 3e2:	10 e0       	ldi	r17, 0x00	; 0

	for (int i = 0; i < 16; i++){	//Loop to shift a total of 16 
		DATA = 0x1c;				//Shifts data to the right 1 
 3e4:	0f 2e       	mov	r0, r31
 3e6:	fc e1       	ldi	r31, 0x1C	; 28
 3e8:	ff 2e       	mov	r15, r31
 3ea:	f0 2d       	mov	r31, r0
 3ec:	f0 92 64 03 	sts	0x0364, r15	; 0x800364 <DATA>
		ASCII = '\0';
 3f0:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <ASCII>
 3f4:	c2 e3       	ldi	r28, 0x32	; 50
 3f6:	d0 e0       	ldi	r29, 0x00	; 0
		for (int j = 0; j < 50; j++){
			UART_Poll();
 3f8:	0e 94 18 01 	call	0x230	; 0x230 <UART_Poll>
			LCD_Delay();	
 3fc:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LCD_Delay>
 400:	21 97       	sbiw	r28, 0x01	; 1
	LCD_Puts(output);				//Puts the output sting onto the LCD

	for (int i = 0; i < 16; i++){	//Loop to shift a total of 16 
		DATA = 0x1c;				//Shifts data to the right 1 
		ASCII = '\0';
		for (int j = 0; j < 50; j++){
 402:	d1 f7       	brne	.-12     	; 0x3f8 <LCD+0x60>
			UART_Poll();
			LCD_Delay();	
		}
		if (ASCII != '\0')
 404:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <ASCII>
 408:	81 11       	cpse	r24, r1
 40a:	05 c0       	rjmp	.+10     	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
			break;
			
		LCD_Write_Command();		//Writes after shift
 40c:	0e 94 c7 00 	call	0x18e	; 0x18e <LCD_Write_Command>
 410:	01 50       	subi	r16, 0x01	; 1
 412:	11 09       	sbc	r17, r1
	DATA = 0x0c;					//Display on cursor off
	LCD_Write_Command();
	
	LCD_Puts(output);				//Puts the output sting onto the LCD

	for (int i = 0; i < 16; i++){	//Loop to shift a total of 16 
 414:	59 f7       	brne	.-42     	; 0x3ec <LCD+0x54>
		if (ASCII != '\0')
			break;
			
		LCD_Write_Command();		//Writes after shift
	} 
}
 416:	df 91       	pop	r29
 418:	cf 91       	pop	r28
 41a:	1f 91       	pop	r17
 41c:	0f 91       	pop	r16
 41e:	ff 90       	pop	r15
 420:	08 95       	ret

00000422 <Temperature_ADC>:

void Temperature_ADC(void)						//Lite Demo of the Analog to Digital Converter
{
 422:	3f 92       	push	r3
 424:	4f 92       	push	r4
 426:	5f 92       	push	r5
 428:	6f 92       	push	r6
 42a:	7f 92       	push	r7
 42c:	8f 92       	push	r8
 42e:	9f 92       	push	r9
 430:	af 92       	push	r10
 432:	bf 92       	push	r11
 434:	cf 92       	push	r12
 436:	df 92       	push	r13
 438:	ef 92       	push	r14
 43a:	ff 92       	push	r15
 43c:	0f 93       	push	r16
 43e:	1f 93       	push	r17
 440:	cf 93       	push	r28
 442:	df 93       	push	r29
	double r, t;									//Values used for calculation
	int rn = 10000;									//Value used for calculation
	ASCII = '\0';
 444:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <ASCII>
	
while(ASCII == '\0' )
	{
	temp[0x2]='.';									//Reserves index 2 in char array for '.'
 448:	cb e6       	ldi	r28, 0x6B	; 107
 44a:	d3 e0       	ldi	r29, 0x03	; 3
 44c:	0f 2e       	mov	r0, r31
 44e:	fe e2       	ldi	r31, 0x2E	; 46
 450:	3f 2e       	mov	r3, r31
 452:	f0 2d       	mov	r31, r0
	temp[0x4]=' ';									//Reserves index 4 in char array for a space
 454:	68 94       	set
 456:	ee 24       	eor	r14, r14
 458:	e5 f8       	bld	r14, 5

    int i = t*10;									//creates an integer i from the the float. Multiplies by 10 to move over decimal point
	int j = t;										//explicit cast of float to int to
	
	temp[0x0] = i / 100 + 48;						//Calculates the first digit in the 2 digits left of the "."
	temp[0x1] = j % 10 + 48;						//Calculates the second digit in the 2 digits left of the "."
 45a:	0f 2e       	mov	r0, r31
 45c:	fa e0       	ldi	r31, 0x0A	; 10
 45e:	cf 2e       	mov	r12, r31
 460:	d1 2c       	mov	r13, r1
 462:	f0 2d       	mov	r31, r0
	UART_Puts(MS7);									//Puts MS7 which is ºF

	ASCII = '\0';
	UART_Poll();
	
	temp[0x0] = 48;									//sets the first digit to 0 to clear
 464:	0f 2e       	mov	r0, r31
 466:	f0 e3       	ldi	r31, 0x30	; 48
 468:	ff 2e       	mov	r15, r31
 46a:	f0 2d       	mov	r31, r0
	int rn = 10000;									//Value used for calculation
	ASCII = '\0';
	
while(ASCII == '\0' )
	{
	temp[0x2]='.';									//Reserves index 2 in char array for '.'
 46c:	3a 82       	std	Y+2, r3	; 0x02
	temp[0x4]=' ';									//Reserves index 4 in char array for a space
 46e:	ec 82       	std	Y+4, r14	; 0x04
	temp[0x5]= 0;									//Does nothing for space 5
 470:	1d 82       	std	Y+5, r1	; 0x05
	
	ADC_Get();										//Gets the ADC value from assembly file
 472:	0e 94 2a 01 	call	0x254	; 0x254 <ADC_Get>
	Acc = (((int)HADC)*0x100+(int)(LADC));			//Calculates given value being read from the circuit into a int
 476:	60 91 65 03 	lds	r22, 0x0365	; 0x800365 <HADC>
 47a:	70 e0       	ldi	r23, 0x00	; 0
 47c:	76 2f       	mov	r23, r22
 47e:	66 27       	eor	r22, r22
 480:	80 91 72 03 	lds	r24, 0x0372	; 0x800372 <LADC>
 484:	68 0f       	add	r22, r24
 486:	71 1d       	adc	r23, r1
 488:	70 93 74 03 	sts	0x0374, r23	; 0x800374 <Acc+0x1>
 48c:	60 93 73 03 	sts	0x0373, r22	; 0x800373 <Acc>
	r = (10000.0 * Acc) / (1024.0 - Acc);			//Equation 1 from given sheet
 490:	07 2e       	mov	r0, r23
 492:	00 0c       	add	r0, r0
 494:	88 0b       	sbc	r24, r24
 496:	99 0b       	sbc	r25, r25
 498:	0e 94 d5 05 	call	0xbaa	; 0xbaa <__floatsisf>
 49c:	4b 01       	movw	r8, r22
 49e:	5c 01       	movw	r10, r24
	t = (3950*298.15)/(298.15*log(r/rn) + 3950);	//Equation 2 from given sheet
 4a0:	20 e0       	ldi	r18, 0x00	; 0
 4a2:	30 e4       	ldi	r19, 0x40	; 64
 4a4:	4c e1       	ldi	r20, 0x1C	; 28
 4a6:	56 e4       	ldi	r21, 0x46	; 70
 4a8:	0e 94 b1 06 	call	0xd62	; 0xd62 <__mulsf3>
 4ac:	2b 01       	movw	r4, r22
 4ae:	3c 01       	movw	r6, r24
 4b0:	a5 01       	movw	r20, r10
 4b2:	94 01       	movw	r18, r8
 4b4:	60 e0       	ldi	r22, 0x00	; 0
 4b6:	70 e0       	ldi	r23, 0x00	; 0
 4b8:	80 e8       	ldi	r24, 0x80	; 128
 4ba:	94 e4       	ldi	r25, 0x44	; 68
 4bc:	0e 94 be 04 	call	0x97c	; 0x97c <__subsf3>
 4c0:	9b 01       	movw	r18, r22
 4c2:	ac 01       	movw	r20, r24
 4c4:	c3 01       	movw	r24, r6
 4c6:	b2 01       	movw	r22, r4
 4c8:	0e 94 2b 05 	call	0xa56	; 0xa56 <__divsf3>
 4cc:	20 e0       	ldi	r18, 0x00	; 0
 4ce:	30 e4       	ldi	r19, 0x40	; 64
 4d0:	4c e1       	ldi	r20, 0x1C	; 28
 4d2:	56 e4       	ldi	r21, 0x46	; 70
 4d4:	0e 94 2b 05 	call	0xa56	; 0xa56 <__divsf3>
 4d8:	0e 94 69 06 	call	0xcd2	; 0xcd2 <log>
 4dc:	23 e3       	ldi	r18, 0x33	; 51
 4de:	33 e1       	ldi	r19, 0x13	; 19
 4e0:	45 e9       	ldi	r20, 0x95	; 149
 4e2:	53 e4       	ldi	r21, 0x43	; 67
 4e4:	0e 94 b1 06 	call	0xd62	; 0xd62 <__mulsf3>
 4e8:	20 e0       	ldi	r18, 0x00	; 0
 4ea:	30 ee       	ldi	r19, 0xE0	; 224
 4ec:	46 e7       	ldi	r20, 0x76	; 118
 4ee:	55 e4       	ldi	r21, 0x45	; 69
 4f0:	0e 94 bf 04 	call	0x97e	; 0x97e <__addsf3>
 4f4:	9b 01       	movw	r18, r22
 4f6:	ac 01       	movw	r20, r24
 4f8:	64 ee       	ldi	r22, 0xE4	; 228
 4fa:	72 ec       	ldi	r23, 0xC2	; 194
 4fc:	8f e8       	ldi	r24, 0x8F	; 143
 4fe:	99 e4       	ldi	r25, 0x49	; 73
 500:	0e 94 2b 05 	call	0xa56	; 0xa56 <__divsf3>
	t = t - 273.15;									//Convert to C from K
 504:	23 e3       	ldi	r18, 0x33	; 51
 506:	33 e9       	ldi	r19, 0x93	; 147
 508:	48 e8       	ldi	r20, 0x88	; 136
 50a:	53 e4       	ldi	r21, 0x43	; 67
 50c:	0e 94 be 04 	call	0x97c	; 0x97c <__subsf3>
	t = t*(9/5) + 32;								//Convert to F from C
 510:	20 e0       	ldi	r18, 0x00	; 0
 512:	30 e0       	ldi	r19, 0x00	; 0
 514:	40 e0       	ldi	r20, 0x00	; 0
 516:	52 e4       	ldi	r21, 0x42	; 66
 518:	0e 94 bf 04 	call	0x97e	; 0x97e <__addsf3>
 51c:	4b 01       	movw	r8, r22
 51e:	5c 01       	movw	r10, r24

    int i = t*10;									//creates an integer i from the the float. Multiplies by 10 to move over decimal point
 520:	20 e0       	ldi	r18, 0x00	; 0
 522:	30 e0       	ldi	r19, 0x00	; 0
 524:	40 e2       	ldi	r20, 0x20	; 32
 526:	51 e4       	ldi	r21, 0x41	; 65
 528:	0e 94 b1 06 	call	0xd62	; 0xd62 <__mulsf3>
 52c:	0e 94 9d 05 	call	0xb3a	; 0xb3a <__fixsfsi>
 530:	8b 01       	movw	r16, r22
	int j = t;										//explicit cast of float to int to
	
	temp[0x0] = i / 100 + 48;						//Calculates the first digit in the 2 digits left of the "."
 532:	cb 01       	movw	r24, r22
 534:	64 e6       	ldi	r22, 0x64	; 100
 536:	70 e0       	ldi	r23, 0x00	; 0
 538:	0e 94 53 07 	call	0xea6	; 0xea6 <__divmodhi4>
 53c:	60 5d       	subi	r22, 0xD0	; 208
 53e:	68 83       	st	Y, r22
	temp[0x1] = j % 10 + 48;						//Calculates the second digit in the 2 digits left of the "."
 540:	c5 01       	movw	r24, r10
 542:	b4 01       	movw	r22, r8
 544:	0e 94 9d 05 	call	0xb3a	; 0xb3a <__fixsfsi>
 548:	cb 01       	movw	r24, r22
 54a:	b6 01       	movw	r22, r12
 54c:	0e 94 53 07 	call	0xea6	; 0xea6 <__divmodhi4>
 550:	80 5d       	subi	r24, 0xD0	; 208
 552:	89 83       	std	Y+1, r24	; 0x01
	temp[0x3] = i % 10 + 48;						//Calculates the values for the decimal
 554:	c8 01       	movw	r24, r16
 556:	b6 01       	movw	r22, r12
 558:	0e 94 53 07 	call	0xea6	; 0xea6 <__divmodhi4>
 55c:	80 5d       	subi	r24, 0xD0	; 208
 55e:	8b 83       	std	Y+3, r24	; 0x03

	UART_Puts(temp);								//Puts the full char array of 'temp'
 560:	ce 01       	movw	r24, r28
 562:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
	UART_Puts(MS7);									//Puts MS7 which is ºF
 566:	86 eb       	ldi	r24, 0xB6	; 182
 568:	92 e0       	ldi	r25, 0x02	; 2
 56a:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>

	ASCII = '\0';
 56e:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <ASCII>
	UART_Poll();
 572:	0e 94 18 01 	call	0x230	; 0x230 <UART_Poll>
	
	temp[0x0] = 48;									//sets the first digit to 0 to clear
 576:	f8 82       	st	Y, r15
	temp[0x1] = 48;									//sets the second digit to 0 to clear
 578:	f9 82       	std	Y+1, r15	; 0x01
	temp[0x3] = 48;									//sets the decimal digit to 0 to clear
 57a:	fb 82       	std	Y+3, r15	; 0x03
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 57c:	2f e3       	ldi	r18, 0x3F	; 63
 57e:	82 e4       	ldi	r24, 0x42	; 66
 580:	9f e0       	ldi	r25, 0x0F	; 15
 582:	21 50       	subi	r18, 0x01	; 1
 584:	80 40       	sbci	r24, 0x00	; 0
 586:	90 40       	sbci	r25, 0x00	; 0
 588:	e1 f7       	brne	.-8      	; 0x582 <Temperature_ADC+0x160>
 58a:	00 c0       	rjmp	.+0      	; 0x58c <Temperature_ADC+0x16a>
 58c:	00 00       	nop
{
	double r, t;									//Values used for calculation
	int rn = 10000;									//Value used for calculation
	ASCII = '\0';
	
while(ASCII == '\0' )
 58e:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <ASCII>
 592:	88 23       	and	r24, r24
 594:	09 f4       	brne	.+2      	; 0x598 <Temperature_ADC+0x176>
 596:	6a cf       	rjmp	.-300    	; 0x46c <Temperature_ADC+0x4a>
	temp[0x1] = 48;									//sets the second digit to 0 to clear
	temp[0x3] = 48;									//sets the decimal digit to 0 to clear
		
	_delay_ms(5000);
	}
	ASCII = '\0';	
 598:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <ASCII>
}
 59c:	df 91       	pop	r29
 59e:	cf 91       	pop	r28
 5a0:	1f 91       	pop	r17
 5a2:	0f 91       	pop	r16
 5a4:	ff 90       	pop	r15
 5a6:	ef 90       	pop	r14
 5a8:	df 90       	pop	r13
 5aa:	cf 90       	pop	r12
 5ac:	bf 90       	pop	r11
 5ae:	af 90       	pop	r10
 5b0:	9f 90       	pop	r9
 5b2:	8f 90       	pop	r8
 5b4:	7f 90       	pop	r7
 5b6:	6f 90       	pop	r6
 5b8:	5f 90       	pop	r5
 5ba:	4f 90       	pop	r4
 5bc:	3f 90       	pop	r3
 5be:	08 95       	ret

000005c0 <EEPROM>:

void EEPROM(void)
{
 5c0:	cf 93       	push	r28
 5c2:	df 93       	push	r29
	UART_Puts("\r\nEEPROM Write and Read.");
 5c4:	88 e4       	ldi	r24, 0x48	; 72
 5c6:	91 e0       	ldi	r25, 0x01	; 1
 5c8:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
	during run-time via the command line and the same byte of data can be read back and verified after the power to
	the Xplained Mini board has been cycled. Ask the user to enter a valid EEPROM address and an
	8-bit data value. Utilize the following two given Assembly based drivers to communicate with the EEPROM. You
	may modify the EEPROM drivers as needed. User must be able to always return to command line.
	*/
	UART_Puts("\r\ninput memory location in this format: 0x####\n\r");
 5cc:	81 e6       	ldi	r24, 0x61	; 97
 5ce:	91 e0       	ldi	r25, 0x01	; 1
 5d0:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
	EEMEMORYR();
 5d4:	0e 94 65 01 	call	0x2ca	; 0x2ca <EEMEMORYR>
	for (int i = 0; i < 6; i++)
 5d8:	c0 e0       	ldi	r28, 0x00	; 0
 5da:	d0 e0       	ldi	r29, 0x00	; 0
	{
		ASCII = '\0';
 5dc:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <ASCII>
		while (ASCII == '\0')
		{
			UART_Get();
 5e0:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>
	UART_Puts("\r\ninput memory location in this format: 0x####\n\r");
	EEMEMORYR();
	for (int i = 0; i < 6; i++)
	{
		ASCII = '\0';
		while (ASCII == '\0')
 5e4:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <ASCII>
 5e8:	88 23       	and	r24, r24
 5ea:	d1 f3       	breq	.-12     	; 0x5e0 <EEPROM+0x20>
		{
			UART_Get();
		}
		UART_Put();
 5ec:	0e 94 21 01 	call	0x242	; 0x242 <UART_Put>
			if(i == 2)
 5f0:	c2 30       	cpi	r28, 0x02	; 2
 5f2:	d1 05       	cpc	r29, r1
 5f4:	49 f4       	brne	.+18     	; 0x608 <EEPROM+0x48>
			{
				DATA = ASCII-48;
				DATA*=16;
 5f6:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <ASCII>
 5fa:	82 95       	swap	r24
 5fc:	80 7f       	andi	r24, 0xF0	; 240
 5fe:	80 93 64 03 	sts	0x0364, r24	; 0x800364 <DATA>
				EEMEMORYH();
 602:	0e 94 55 01 	call	0x2aa	; 0x2aa <EEMEMORYH>
 606:	18 c0       	rjmp	.+48     	; 0x638 <EEPROM+0x78>
			}
			if (i == 3)
 608:	c3 30       	cpi	r28, 0x03	; 3
 60a:	d1 05       	cpc	r29, r1
 60c:	41 f4       	brne	.+16     	; 0x61e <EEPROM+0x5e>
			{
				DATA = ASCII-48;
 60e:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <ASCII>
 612:	80 53       	subi	r24, 0x30	; 48
 614:	80 93 64 03 	sts	0x0364, r24	; 0x800364 <DATA>
				EEMEMORYH();
 618:	0e 94 55 01 	call	0x2aa	; 0x2aa <EEMEMORYH>
 61c:	18 c0       	rjmp	.+48     	; 0x64e <EEPROM+0x8e>
			}
				
			if (i == 4)
 61e:	c4 30       	cpi	r28, 0x04	; 4
 620:	d1 05       	cpc	r29, r1
 622:	51 f4       	brne	.+20     	; 0x638 <EEPROM+0x78>
			{
				DATA = ASCII-48;
				DATA*=16;
 624:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <ASCII>
 628:	82 95       	swap	r24
 62a:	80 7f       	andi	r24, 0xF0	; 240
 62c:	80 93 64 03 	sts	0x0364, r24	; 0x800364 <DATA>
				EEMEMORYL();
 630:	0e 94 5d 01 	call	0x2ba	; 0x2ba <EEMEMORYL>
	8-bit data value. Utilize the following two given Assembly based drivers to communicate with the EEPROM. You
	may modify the EEPROM drivers as needed. User must be able to always return to command line.
	*/
	UART_Puts("\r\ninput memory location in this format: 0x####\n\r");
	EEMEMORYR();
	for (int i = 0; i < 6; i++)
 634:	21 96       	adiw	r28, 0x01	; 1
 636:	d2 cf       	rjmp	.-92     	; 0x5dc <EEPROM+0x1c>
			{
				DATA = ASCII-48;
				DATA*=16;
				EEMEMORYL();
			}
			if (i == 5)
 638:	c5 30       	cpi	r28, 0x05	; 5
 63a:	d1 05       	cpc	r29, r1
 63c:	41 f4       	brne	.+16     	; 0x64e <EEPROM+0x8e>
			{
				DATA = ASCII-48;
 63e:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <ASCII>
 642:	80 53       	subi	r24, 0x30	; 48
 644:	80 93 64 03 	sts	0x0364, r24	; 0x800364 <DATA>
				EEMEMORYL();
 648:	0e 94 5d 01 	call	0x2ba	; 0x2ba <EEMEMORYL>
 64c:	04 c0       	rjmp	.+8      	; 0x656 <EEPROM+0x96>
	8-bit data value. Utilize the following two given Assembly based drivers to communicate with the EEPROM. You
	may modify the EEPROM drivers as needed. User must be able to always return to command line.
	*/
	UART_Puts("\r\ninput memory location in this format: 0x####\n\r");
	EEMEMORYR();
	for (int i = 0; i < 6; i++)
 64e:	21 96       	adiw	r28, 0x01	; 1
 650:	c6 30       	cpi	r28, 0x06	; 6
 652:	d1 05       	cpc	r29, r1
 654:	19 f6       	brne	.-122    	; 0x5dc <EEPROM+0x1c>
				DATA = ASCII-48;
				EEMEMORYL();
			}
			
	}
	UART_Puts("\r\n");
 656:	88 eb       	ldi	r24, 0xB8	; 184
 658:	91 e0       	ldi	r25, 0x01	; 1
 65a:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
	EEPROM_Write();
 65e:	0e 94 3a 01 	call	0x274	; 0x274 <EEPROM_Write>
	UART_Puts("\r\n");
 662:	88 eb       	ldi	r24, 0xB8	; 184
 664:	91 e0       	ldi	r25, 0x01	; 1
 666:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
	EEPROM_Read();
 66a:	0e 94 47 01 	call	0x28e	; 0x28e <EEPROM_Read>
	UART_Put();
 66e:	0e 94 21 01 	call	0x242	; 0x242 <UART_Put>
	UART_Puts("\r\n");
 672:	88 eb       	ldi	r24, 0xB8	; 184
 674:	91 e0       	ldi	r25, 0x01	; 1
 676:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
}
 67a:	df 91       	pop	r29
 67c:	cf 91       	pop	r28
 67e:	08 95       	ret

00000680 <BAUD>:

void BAUD(void)
{
	UART_Puts("\r\nBaud rater\n(1)9600\r\n(2)2400\r\n(3)1200\r\n");
 680:	82 e9       	ldi	r24, 0x92	; 146
 682:	91 e0       	ldi	r25, 0x01	; 1
 684:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
	ASCII = '\0';
 688:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 68c:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>

void BAUD(void)
{
	UART_Puts("\r\nBaud rater\n(1)9600\r\n(2)2400\r\n(3)1200\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 690:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <ASCII>
 694:	88 23       	and	r24, r24
 696:	d1 f3       	breq	.-12     	; 0x68c <BAUD+0xc>
	{
		UART_Get();
	}
	switch (ASCII)
 698:	82 33       	cpi	r24, 0x32	; 50
 69a:	89 f0       	breq	.+34     	; 0x6be <BAUD+0x3e>
 69c:	83 33       	cpi	r24, 0x33	; 51
 69e:	f1 f0       	breq	.+60     	; 0x6dc <BAUD+0x5c>
 6a0:	81 33       	cpi	r24, 0x31	; 49
 6a2:	59 f5       	brne	.+86     	; 0x6fa <BAUD+0x7a>
	{
		case '1':
		BAUDH = 0;
 6a4:	10 92 67 03 	sts	0x0367, r1	; 0x800367 <BAUDH+0x1>
 6a8:	10 92 66 03 	sts	0x0366, r1	; 0x800366 <BAUDH>
		BAUDL = 103;
 6ac:	87 e6       	ldi	r24, 0x67	; 103
 6ae:	90 e0       	ldi	r25, 0x00	; 0
 6b0:	90 93 76 03 	sts	0x0376, r25	; 0x800376 <BAUDL+0x1>
 6b4:	80 93 75 03 	sts	0x0375, r24	; 0x800375 <BAUDL>
		SETBAUD();
 6b8:	0e 94 8f 01 	call	0x31e	; 0x31e <SETBAUD>
		break;
 6bc:	08 95       	ret
		case '2':
		BAUDH = 1;
 6be:	81 e0       	ldi	r24, 0x01	; 1
 6c0:	90 e0       	ldi	r25, 0x00	; 0
 6c2:	90 93 67 03 	sts	0x0367, r25	; 0x800367 <BAUDH+0x1>
 6c6:	80 93 66 03 	sts	0x0366, r24	; 0x800366 <BAUDH>
		BAUDL = 159;
 6ca:	8f e9       	ldi	r24, 0x9F	; 159
 6cc:	90 e0       	ldi	r25, 0x00	; 0
 6ce:	90 93 76 03 	sts	0x0376, r25	; 0x800376 <BAUDL+0x1>
 6d2:	80 93 75 03 	sts	0x0375, r24	; 0x800375 <BAUDL>
		SETBAUD();
 6d6:	0e 94 8f 01 	call	0x31e	; 0x31e <SETBAUD>
		break;
 6da:	08 95       	ret
		case '3':
		BAUDH = 3;
 6dc:	83 e0       	ldi	r24, 0x03	; 3
 6de:	90 e0       	ldi	r25, 0x00	; 0
 6e0:	90 93 67 03 	sts	0x0367, r25	; 0x800367 <BAUDH+0x1>
 6e4:	80 93 66 03 	sts	0x0366, r24	; 0x800366 <BAUDH>
		BAUDL = 63;
 6e8:	8f e3       	ldi	r24, 0x3F	; 63
 6ea:	90 e0       	ldi	r25, 0x00	; 0
 6ec:	90 93 76 03 	sts	0x0376, r25	; 0x800376 <BAUDL+0x1>
 6f0:	80 93 75 03 	sts	0x0375, r24	; 0x800375 <BAUDL>
		SETBAUD();
 6f4:	0e 94 8f 01 	call	0x31e	; 0x31e <SETBAUD>
		break;
 6f8:	08 95       	ret
		default:
		UART_Puts("\r\nIncorrect input\r\n");
 6fa:	8b eb       	ldi	r24, 0xBB	; 187
 6fc:	91 e0       	ldi	r25, 0x01	; 1
 6fe:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
 702:	08 95       	ret

00000704 <DATAb>:
	}

}

void DATAb(void)
{
 704:	cf 93       	push	r28
 706:	df 93       	push	r29
	UART_Puts("\r\n# of Data Bits\r\n(1)5-bits\r\n(2)6-bits\r\n(3)7-bits\r\n(4)8-bits\r\n(5)9-bits\r\n");
 708:	8f ec       	ldi	r24, 0xCF	; 207
 70a:	91 e0       	ldi	r25, 0x01	; 1
 70c:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
	ASCII = '\0';
 710:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 714:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>

void DATAb(void)
{
	UART_Puts("\r\n# of Data Bits\r\n(1)5-bits\r\n(2)6-bits\r\n(3)7-bits\r\n(4)8-bits\r\n(5)9-bits\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 718:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <ASCII>
 71c:	88 23       	and	r24, r24
 71e:	d1 f3       	breq	.-12     	; 0x714 <DATAb+0x10>
	{
		UART_Get();
	}
	switch (ASCII)
 720:	83 33       	cpi	r24, 0x33	; 51
 722:	a9 f1       	breq	.+106    	; 0x78e <DATAb+0x8a>
 724:	28 f4       	brcc	.+10     	; 0x730 <DATAb+0x2c>
 726:	81 33       	cpi	r24, 0x31	; 49
 728:	51 f0       	breq	.+20     	; 0x73e <DATAb+0x3a>
 72a:	82 33       	cpi	r24, 0x32	; 50
 72c:	c9 f0       	breq	.+50     	; 0x760 <DATAb+0x5c>
 72e:	68 c0       	rjmp	.+208    	; 0x800 <DATAb+0xfc>
 730:	84 33       	cpi	r24, 0x34	; 52
 732:	09 f4       	brne	.+2      	; 0x736 <DATAb+0x32>
 734:	43 c0       	rjmp	.+134    	; 0x7bc <DATAb+0xb8>
 736:	85 33       	cpi	r24, 0x35	; 53
 738:	09 f4       	brne	.+2      	; 0x73c <DATAb+0x38>
 73a:	51 c0       	rjmp	.+162    	; 0x7de <DATAb+0xda>
 73c:	61 c0       	rjmp	.+194    	; 0x800 <DATAb+0xfc>
	{
		case '1':
		USARTDATA = 6;
 73e:	86 e0       	ldi	r24, 0x06	; 6
 740:	90 e0       	ldi	r25, 0x00	; 0
 742:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <__data_end+0x1>
 746:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <__data_end>
		CLEARC();
 74a:	0e 94 73 01 	call	0x2e6	; 0x2e6 <CLEARC>
		USARTDATA = 4;
 74e:	84 e0       	ldi	r24, 0x04	; 4
 750:	90 e0       	ldi	r25, 0x00	; 0
 752:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <__data_end+0x1>
 756:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <__data_end>
		CLEARB();
 75a:	0e 94 87 01 	call	0x30e	; 0x30e <CLEARB>
		break;
 75e:	54 c0       	rjmp	.+168    	; 0x808 <DATAb+0x104>
		case '2':
		USARTDATA = 4;
 760:	c4 e0       	ldi	r28, 0x04	; 4
 762:	d0 e0       	ldi	r29, 0x00	; 0
 764:	d0 93 63 03 	sts	0x0363, r29	; 0x800363 <__data_end+0x1>
 768:	c0 93 62 03 	sts	0x0362, r28	; 0x800362 <__data_end>
		CLEARC();
 76c:	0e 94 73 01 	call	0x2e6	; 0x2e6 <CLEARC>
		USARTDATA = 2;
 770:	82 e0       	ldi	r24, 0x02	; 2
 772:	90 e0       	ldi	r25, 0x00	; 0
 774:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <__data_end+0x1>
 778:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <__data_end>
		SETC();
 77c:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <SETC>
		USARTDATA = 4;
 780:	d0 93 63 03 	sts	0x0363, r29	; 0x800363 <__data_end+0x1>
 784:	c0 93 62 03 	sts	0x0362, r28	; 0x800362 <__data_end>
		CLEARB();
 788:	0e 94 87 01 	call	0x30e	; 0x30e <CLEARB>
		break;
 78c:	3d c0       	rjmp	.+122    	; 0x808 <DATAb+0x104>
		case '3':
		USARTDATA = 4;
 78e:	c4 e0       	ldi	r28, 0x04	; 4
 790:	d0 e0       	ldi	r29, 0x00	; 0
 792:	d0 93 63 03 	sts	0x0363, r29	; 0x800363 <__data_end+0x1>
 796:	c0 93 62 03 	sts	0x0362, r28	; 0x800362 <__data_end>
		SETC();
 79a:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <SETC>
		USARTDATA = 2;
 79e:	82 e0       	ldi	r24, 0x02	; 2
 7a0:	90 e0       	ldi	r25, 0x00	; 0
 7a2:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <__data_end+0x1>
 7a6:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <__data_end>
		CLEARC();
 7aa:	0e 94 73 01 	call	0x2e6	; 0x2e6 <CLEARC>
		USARTDATA = 4;
 7ae:	d0 93 63 03 	sts	0x0363, r29	; 0x800363 <__data_end+0x1>
 7b2:	c0 93 62 03 	sts	0x0362, r28	; 0x800362 <__data_end>
		CLEARB();
 7b6:	0e 94 87 01 	call	0x30e	; 0x30e <CLEARB>
		break;
 7ba:	26 c0       	rjmp	.+76     	; 0x808 <DATAb+0x104>
		case '4':
		USARTDATA = 6;
 7bc:	86 e0       	ldi	r24, 0x06	; 6
 7be:	90 e0       	ldi	r25, 0x00	; 0
 7c0:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <__data_end+0x1>
 7c4:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <__data_end>
		SETC();
 7c8:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <SETC>
		USARTDATA = 4;
 7cc:	84 e0       	ldi	r24, 0x04	; 4
 7ce:	90 e0       	ldi	r25, 0x00	; 0
 7d0:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <__data_end+0x1>
 7d4:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <__data_end>
		CLEARB();
 7d8:	0e 94 87 01 	call	0x30e	; 0x30e <CLEARB>
		break;
 7dc:	15 c0       	rjmp	.+42     	; 0x808 <DATAb+0x104>
		case '5':
		USARTDATA = 6;
 7de:	86 e0       	ldi	r24, 0x06	; 6
 7e0:	90 e0       	ldi	r25, 0x00	; 0
 7e2:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <__data_end+0x1>
 7e6:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <__data_end>
		SETC();
 7ea:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <SETC>
		USARTDATA = 4;
 7ee:	84 e0       	ldi	r24, 0x04	; 4
 7f0:	90 e0       	ldi	r25, 0x00	; 0
 7f2:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <__data_end+0x1>
 7f6:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <__data_end>
		SETB();
 7fa:	0e 94 7d 01 	call	0x2fa	; 0x2fa <SETB>
		break;
 7fe:	04 c0       	rjmp	.+8      	; 0x808 <DATAb+0x104>
		default:
		UART_Puts("\r\nIncorrect input\r\n");
 800:	8b eb       	ldi	r24, 0xBB	; 187
 802:	91 e0       	ldi	r25, 0x01	; 1
 804:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
		break;
	}
}
 808:	df 91       	pop	r29
 80a:	cf 91       	pop	r28
 80c:	08 95       	ret

0000080e <PARITY>:

void PARITY(void)
{
	UART_Puts("\r\nParity\r\n(1)even\r\n(2)odd\r\n(3)none\r\n");
 80e:	89 e1       	ldi	r24, 0x19	; 25
 810:	92 e0       	ldi	r25, 0x02	; 2
 812:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
	ASCII = '\0';
 816:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 81a:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>

void PARITY(void)
{
	UART_Puts("\r\nParity\r\n(1)even\r\n(2)odd\r\n(3)none\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 81e:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <ASCII>
 822:	88 23       	and	r24, r24
 824:	d1 f3       	breq	.-12     	; 0x81a <PARITY+0xc>
	{
		UART_Get();
	}
	switch (ASCII)
 826:	82 33       	cpi	r24, 0x32	; 50
 828:	69 f0       	breq	.+26     	; 0x844 <PARITY+0x36>
 82a:	83 33       	cpi	r24, 0x33	; 51
 82c:	e1 f0       	breq	.+56     	; 0x866 <PARITY+0x58>
 82e:	81 33       	cpi	r24, 0x31	; 49
 830:	19 f5       	brne	.+70     	; 0x878 <PARITY+0x6a>
	{
		case '1':
		USARTDATA = 48;
 832:	80 e3       	ldi	r24, 0x30	; 48
 834:	90 e0       	ldi	r25, 0x00	; 0
 836:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <__data_end+0x1>
 83a:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <__data_end>
		CLEARC();
 83e:	0e 94 73 01 	call	0x2e6	; 0x2e6 <CLEARC>
		break;
 842:	08 95       	ret
		case '2':
		USARTDATA = 32;
 844:	80 e2       	ldi	r24, 0x20	; 32
 846:	90 e0       	ldi	r25, 0x00	; 0
 848:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <__data_end+0x1>
 84c:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <__data_end>
		SETC();
 850:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <SETC>
		USARTDATA = 16;
 854:	80 e1       	ldi	r24, 0x10	; 16
 856:	90 e0       	ldi	r25, 0x00	; 0
 858:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <__data_end+0x1>
 85c:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <__data_end>
		CLEARC();
 860:	0e 94 73 01 	call	0x2e6	; 0x2e6 <CLEARC>
		break;
 864:	08 95       	ret
		case '3':
		USARTDATA = 48;
 866:	80 e3       	ldi	r24, 0x30	; 48
 868:	90 e0       	ldi	r25, 0x00	; 0
 86a:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <__data_end+0x1>
 86e:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <__data_end>
		SETC();
 872:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <SETC>
		break;
 876:	08 95       	ret
		default:
		UART_Puts("\r\nIncorrect input\r\n");
 878:	8b eb       	ldi	r24, 0xBB	; 187
 87a:	91 e0       	ldi	r25, 0x01	; 1
 87c:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
 880:	08 95       	ret

00000882 <STOPb>:
	}
}

void STOPb(void)
{
	USARTDATA = 8;
 882:	88 e0       	ldi	r24, 0x08	; 8
 884:	90 e0       	ldi	r25, 0x00	; 0
 886:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <__data_end+0x1>
 88a:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <__data_end>
	UART_Puts("\r\n# of Stop bits\r\n(1)1-bit\r\n(2)2-bits\r\n");
 88e:	8e e3       	ldi	r24, 0x3E	; 62
 890:	92 e0       	ldi	r25, 0x02	; 2
 892:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
	ASCII = '\0';
 896:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 89a:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>
void STOPb(void)
{
	USARTDATA = 8;
	UART_Puts("\r\n# of Stop bits\r\n(1)1-bit\r\n(2)2-bits\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 89e:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <ASCII>
 8a2:	88 23       	and	r24, r24
 8a4:	d1 f3       	breq	.-12     	; 0x89a <STOPb+0x18>
	{
		UART_Get();
	}
	switch (ASCII)
 8a6:	81 33       	cpi	r24, 0x31	; 49
 8a8:	19 f0       	breq	.+6      	; 0x8b0 <STOPb+0x2e>
 8aa:	82 33       	cpi	r24, 0x32	; 50
 8ac:	21 f0       	breq	.+8      	; 0x8b6 <STOPb+0x34>
 8ae:	06 c0       	rjmp	.+12     	; 0x8bc <STOPb+0x3a>
	{
		case '1': CLEARC();
 8b0:	0e 94 73 01 	call	0x2e6	; 0x2e6 <CLEARC>
		break;
 8b4:	08 95       	ret
		case '2': SETC();
 8b6:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <SETC>
		break;
 8ba:	08 95       	ret
		default:
		UART_Puts("\r\nIncorrect input\r\n");
 8bc:	8b eb       	ldi	r24, 0xBB	; 187
 8be:	91 e0       	ldi	r25, 0x01	; 1
 8c0:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
 8c4:	08 95       	ret

000008c6 <USART>:
	}
}

void USART(void)
{
	UART_Puts("\r\nUSART Config\r\n(1)Baud Rate\r\n(2)# of Data bits\r\n(3)Parity\r\n(4)# of Stop Bits\r\n");
 8c6:	86 e6       	ldi	r24, 0x66	; 102
 8c8:	92 e0       	ldi	r25, 0x02	; 2
 8ca:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
	ASCII = '\0';
 8ce:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 8d2:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>

void USART(void)
{
	UART_Puts("\r\nUSART Config\r\n(1)Baud Rate\r\n(2)# of Data bits\r\n(3)Parity\r\n(4)# of Stop Bits\r\n");
	ASCII = '\0';
	while (ASCII == '\0')
 8d6:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <ASCII>
 8da:	88 23       	and	r24, r24
 8dc:	d1 f3       	breq	.-12     	; 0x8d2 <USART+0xc>
	{
		UART_Get();
	}
	switch (ASCII)
 8de:	82 33       	cpi	r24, 0x32	; 50
 8e0:	61 f0       	breq	.+24     	; 0x8fa <USART+0x34>
 8e2:	18 f4       	brcc	.+6      	; 0x8ea <USART+0x24>
 8e4:	81 33       	cpi	r24, 0x31	; 49
 8e6:	31 f0       	breq	.+12     	; 0x8f4 <USART+0x2e>
 8e8:	11 c0       	rjmp	.+34     	; 0x90c <__stack+0xd>
 8ea:	83 33       	cpi	r24, 0x33	; 51
 8ec:	49 f0       	breq	.+18     	; 0x900 <__stack+0x1>
 8ee:	84 33       	cpi	r24, 0x34	; 52
 8f0:	51 f0       	breq	.+20     	; 0x906 <__stack+0x7>
 8f2:	0c c0       	rjmp	.+24     	; 0x90c <__stack+0xd>
	{
		case '1': BAUD();
 8f4:	0e 94 40 03 	call	0x680	; 0x680 <BAUD>
		break;
 8f8:	08 95       	ret
		case '2': DATAb();
 8fa:	0e 94 82 03 	call	0x704	; 0x704 <DATAb>
		break;
 8fe:	08 95       	ret
		case '3': PARITY();
 900:	0e 94 07 04 	call	0x80e	; 0x80e <PARITY>
		break;
 904:	08 95       	ret
		case '4': STOPb();
 906:	0e 94 41 04 	call	0x882	; 0x882 <STOPb>
		break;
 90a:	08 95       	ret
		default:
		UART_Puts("\r\nIncorrect input\r\n");
 90c:	8b eb       	ldi	r24, 0xBB	; 187
 90e:	91 e0       	ldi	r25, 0x01	; 1
 910:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
 914:	08 95       	ret

00000916 <Command>:
	}
}

void Command(void)					//command interpreter
{
	UART_On();
 916:	0e 94 fe 00 	call	0x1fc	; 0x1fc <UART_On>
	UART_Puts(MS3);
 91a:	82 ee       	ldi	r24, 0xE2	; 226
 91c:	92 e0       	ldi	r25, 0x02	; 2
 91e:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
	ASCII = '\0';						
 922:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 926:	0e 94 0f 01 	call	0x21e	; 0x21e <UART_Get>
void Command(void)					//command interpreter
{
	UART_On();
	UART_Puts(MS3);
	ASCII = '\0';						
	while (ASCII == '\0')
 92a:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <ASCII>
 92e:	88 23       	and	r24, r24
 930:	d1 f3       	breq	.-12     	; 0x926 <Command+0x10>
	{
		UART_Get();
	}
	switch (ASCII)
 932:	85 36       	cpi	r24, 0x65	; 101
 934:	79 f0       	breq	.+30     	; 0x954 <Command+0x3e>
 936:	18 f4       	brcc	.+6      	; 0x93e <Command+0x28>
 938:	81 36       	cpi	r24, 0x61	; 97
 93a:	49 f0       	breq	.+18     	; 0x94e <Command+0x38>
 93c:	11 c0       	rjmp	.+34     	; 0x960 <Command+0x4a>
 93e:	8c 36       	cpi	r24, 0x6C	; 108
 940:	19 f0       	breq	.+6      	; 0x948 <Command+0x32>
 942:	85 37       	cpi	r24, 0x75	; 117
 944:	51 f0       	breq	.+20     	; 0x95a <Command+0x44>
 946:	0c c0       	rjmp	.+24     	; 0x960 <Command+0x4a>
	{
		case 'L' | 'l': LCD();
 948:	0e 94 cc 01 	call	0x398	; 0x398 <LCD>
		break;
 94c:	08 95       	ret
		case 'A' | 'a': Temperature_ADC();
 94e:	0e 94 11 02 	call	0x422	; 0x422 <Temperature_ADC>
		break;
 952:	08 95       	ret
		case 'E' | 'e': EEPROM();
 954:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <EEPROM>
		break;
 958:	08 95       	ret
		case 'U' | 'u': USART();
 95a:	0e 94 63 04 	call	0x8c6	; 0x8c6 <USART>
		break;
 95e:	08 95       	ret
		default:
		UART_Puts(MS5);
 960:	89 eb       	ldi	r24, 0xB9	; 185
 962:	92 e0       	ldi	r25, 0x02	; 2
 964:	0e 94 98 01 	call	0x330	; 0x330 <UART_Puts>
		HELP();
 968:	0e 94 c7 01 	call	0x38e	; 0x38e <HELP>
 96c:	08 95       	ret

0000096e <main>:
	}
}

int main(void)
{
	Mega328P_Init();
 96e:	0e 94 a6 00 	call	0x14c	; 0x14c <Mega328P_Init>
	Banner();
 972:	0e 94 ba 01 	call	0x374	; 0x374 <Banner>
	while (1)
	{
		Command();				//infinite command loop
 976:	0e 94 8b 04 	call	0x916	; 0x916 <Command>
 97a:	fd cf       	rjmp	.-6      	; 0x976 <main+0x8>

0000097c <__subsf3>:
 97c:	50 58       	subi	r21, 0x80	; 128

0000097e <__addsf3>:
 97e:	bb 27       	eor	r27, r27
 980:	aa 27       	eor	r26, r26
 982:	0e 94 d6 04 	call	0x9ac	; 0x9ac <__addsf3x>
 986:	0c 94 27 06 	jmp	0xc4e	; 0xc4e <__fp_round>
 98a:	0e 94 19 06 	call	0xc32	; 0xc32 <__fp_pscA>
 98e:	38 f0       	brcs	.+14     	; 0x99e <__addsf3+0x20>
 990:	0e 94 20 06 	call	0xc40	; 0xc40 <__fp_pscB>
 994:	20 f0       	brcs	.+8      	; 0x99e <__addsf3+0x20>
 996:	39 f4       	brne	.+14     	; 0x9a6 <__addsf3+0x28>
 998:	9f 3f       	cpi	r25, 0xFF	; 255
 99a:	19 f4       	brne	.+6      	; 0x9a2 <__addsf3+0x24>
 99c:	26 f4       	brtc	.+8      	; 0x9a6 <__addsf3+0x28>
 99e:	0c 94 16 06 	jmp	0xc2c	; 0xc2c <__fp_nan>
 9a2:	0e f4       	brtc	.+2      	; 0x9a6 <__addsf3+0x28>
 9a4:	e0 95       	com	r30
 9a6:	e7 fb       	bst	r30, 7
 9a8:	0c 94 10 06 	jmp	0xc20	; 0xc20 <__fp_inf>

000009ac <__addsf3x>:
 9ac:	e9 2f       	mov	r30, r25
 9ae:	0e 94 38 06 	call	0xc70	; 0xc70 <__fp_split3>
 9b2:	58 f3       	brcs	.-42     	; 0x98a <__addsf3+0xc>
 9b4:	ba 17       	cp	r27, r26
 9b6:	62 07       	cpc	r22, r18
 9b8:	73 07       	cpc	r23, r19
 9ba:	84 07       	cpc	r24, r20
 9bc:	95 07       	cpc	r25, r21
 9be:	20 f0       	brcs	.+8      	; 0x9c8 <__addsf3x+0x1c>
 9c0:	79 f4       	brne	.+30     	; 0x9e0 <__addsf3x+0x34>
 9c2:	a6 f5       	brtc	.+104    	; 0xa2c <__addsf3x+0x80>
 9c4:	0c 94 5a 06 	jmp	0xcb4	; 0xcb4 <__fp_zero>
 9c8:	0e f4       	brtc	.+2      	; 0x9cc <__addsf3x+0x20>
 9ca:	e0 95       	com	r30
 9cc:	0b 2e       	mov	r0, r27
 9ce:	ba 2f       	mov	r27, r26
 9d0:	a0 2d       	mov	r26, r0
 9d2:	0b 01       	movw	r0, r22
 9d4:	b9 01       	movw	r22, r18
 9d6:	90 01       	movw	r18, r0
 9d8:	0c 01       	movw	r0, r24
 9da:	ca 01       	movw	r24, r20
 9dc:	a0 01       	movw	r20, r0
 9de:	11 24       	eor	r1, r1
 9e0:	ff 27       	eor	r31, r31
 9e2:	59 1b       	sub	r21, r25
 9e4:	99 f0       	breq	.+38     	; 0xa0c <__addsf3x+0x60>
 9e6:	59 3f       	cpi	r21, 0xF9	; 249
 9e8:	50 f4       	brcc	.+20     	; 0x9fe <__addsf3x+0x52>
 9ea:	50 3e       	cpi	r21, 0xE0	; 224
 9ec:	68 f1       	brcs	.+90     	; 0xa48 <__addsf3x+0x9c>
 9ee:	1a 16       	cp	r1, r26
 9f0:	f0 40       	sbci	r31, 0x00	; 0
 9f2:	a2 2f       	mov	r26, r18
 9f4:	23 2f       	mov	r18, r19
 9f6:	34 2f       	mov	r19, r20
 9f8:	44 27       	eor	r20, r20
 9fa:	58 5f       	subi	r21, 0xF8	; 248
 9fc:	f3 cf       	rjmp	.-26     	; 0x9e4 <__addsf3x+0x38>
 9fe:	46 95       	lsr	r20
 a00:	37 95       	ror	r19
 a02:	27 95       	ror	r18
 a04:	a7 95       	ror	r26
 a06:	f0 40       	sbci	r31, 0x00	; 0
 a08:	53 95       	inc	r21
 a0a:	c9 f7       	brne	.-14     	; 0x9fe <__addsf3x+0x52>
 a0c:	7e f4       	brtc	.+30     	; 0xa2c <__addsf3x+0x80>
 a0e:	1f 16       	cp	r1, r31
 a10:	ba 0b       	sbc	r27, r26
 a12:	62 0b       	sbc	r22, r18
 a14:	73 0b       	sbc	r23, r19
 a16:	84 0b       	sbc	r24, r20
 a18:	ba f0       	brmi	.+46     	; 0xa48 <__addsf3x+0x9c>
 a1a:	91 50       	subi	r25, 0x01	; 1
 a1c:	a1 f0       	breq	.+40     	; 0xa46 <__addsf3x+0x9a>
 a1e:	ff 0f       	add	r31, r31
 a20:	bb 1f       	adc	r27, r27
 a22:	66 1f       	adc	r22, r22
 a24:	77 1f       	adc	r23, r23
 a26:	88 1f       	adc	r24, r24
 a28:	c2 f7       	brpl	.-16     	; 0xa1a <__addsf3x+0x6e>
 a2a:	0e c0       	rjmp	.+28     	; 0xa48 <__addsf3x+0x9c>
 a2c:	ba 0f       	add	r27, r26
 a2e:	62 1f       	adc	r22, r18
 a30:	73 1f       	adc	r23, r19
 a32:	84 1f       	adc	r24, r20
 a34:	48 f4       	brcc	.+18     	; 0xa48 <__addsf3x+0x9c>
 a36:	87 95       	ror	r24
 a38:	77 95       	ror	r23
 a3a:	67 95       	ror	r22
 a3c:	b7 95       	ror	r27
 a3e:	f7 95       	ror	r31
 a40:	9e 3f       	cpi	r25, 0xFE	; 254
 a42:	08 f0       	brcs	.+2      	; 0xa46 <__addsf3x+0x9a>
 a44:	b0 cf       	rjmp	.-160    	; 0x9a6 <__addsf3+0x28>
 a46:	93 95       	inc	r25
 a48:	88 0f       	add	r24, r24
 a4a:	08 f0       	brcs	.+2      	; 0xa4e <__addsf3x+0xa2>
 a4c:	99 27       	eor	r25, r25
 a4e:	ee 0f       	add	r30, r30
 a50:	97 95       	ror	r25
 a52:	87 95       	ror	r24
 a54:	08 95       	ret

00000a56 <__divsf3>:
 a56:	0e 94 3f 05 	call	0xa7e	; 0xa7e <__divsf3x>
 a5a:	0c 94 27 06 	jmp	0xc4e	; 0xc4e <__fp_round>
 a5e:	0e 94 20 06 	call	0xc40	; 0xc40 <__fp_pscB>
 a62:	58 f0       	brcs	.+22     	; 0xa7a <__divsf3+0x24>
 a64:	0e 94 19 06 	call	0xc32	; 0xc32 <__fp_pscA>
 a68:	40 f0       	brcs	.+16     	; 0xa7a <__divsf3+0x24>
 a6a:	29 f4       	brne	.+10     	; 0xa76 <__divsf3+0x20>
 a6c:	5f 3f       	cpi	r21, 0xFF	; 255
 a6e:	29 f0       	breq	.+10     	; 0xa7a <__divsf3+0x24>
 a70:	0c 94 10 06 	jmp	0xc20	; 0xc20 <__fp_inf>
 a74:	51 11       	cpse	r21, r1
 a76:	0c 94 5b 06 	jmp	0xcb6	; 0xcb6 <__fp_szero>
 a7a:	0c 94 16 06 	jmp	0xc2c	; 0xc2c <__fp_nan>

00000a7e <__divsf3x>:
 a7e:	0e 94 38 06 	call	0xc70	; 0xc70 <__fp_split3>
 a82:	68 f3       	brcs	.-38     	; 0xa5e <__divsf3+0x8>

00000a84 <__divsf3_pse>:
 a84:	99 23       	and	r25, r25
 a86:	b1 f3       	breq	.-20     	; 0xa74 <__divsf3+0x1e>
 a88:	55 23       	and	r21, r21
 a8a:	91 f3       	breq	.-28     	; 0xa70 <__divsf3+0x1a>
 a8c:	95 1b       	sub	r25, r21
 a8e:	55 0b       	sbc	r21, r21
 a90:	bb 27       	eor	r27, r27
 a92:	aa 27       	eor	r26, r26
 a94:	62 17       	cp	r22, r18
 a96:	73 07       	cpc	r23, r19
 a98:	84 07       	cpc	r24, r20
 a9a:	38 f0       	brcs	.+14     	; 0xaaa <__divsf3_pse+0x26>
 a9c:	9f 5f       	subi	r25, 0xFF	; 255
 a9e:	5f 4f       	sbci	r21, 0xFF	; 255
 aa0:	22 0f       	add	r18, r18
 aa2:	33 1f       	adc	r19, r19
 aa4:	44 1f       	adc	r20, r20
 aa6:	aa 1f       	adc	r26, r26
 aa8:	a9 f3       	breq	.-22     	; 0xa94 <__divsf3_pse+0x10>
 aaa:	35 d0       	rcall	.+106    	; 0xb16 <__divsf3_pse+0x92>
 aac:	0e 2e       	mov	r0, r30
 aae:	3a f0       	brmi	.+14     	; 0xabe <__divsf3_pse+0x3a>
 ab0:	e0 e8       	ldi	r30, 0x80	; 128
 ab2:	32 d0       	rcall	.+100    	; 0xb18 <__divsf3_pse+0x94>
 ab4:	91 50       	subi	r25, 0x01	; 1
 ab6:	50 40       	sbci	r21, 0x00	; 0
 ab8:	e6 95       	lsr	r30
 aba:	00 1c       	adc	r0, r0
 abc:	ca f7       	brpl	.-14     	; 0xab0 <__divsf3_pse+0x2c>
 abe:	2b d0       	rcall	.+86     	; 0xb16 <__divsf3_pse+0x92>
 ac0:	fe 2f       	mov	r31, r30
 ac2:	29 d0       	rcall	.+82     	; 0xb16 <__divsf3_pse+0x92>
 ac4:	66 0f       	add	r22, r22
 ac6:	77 1f       	adc	r23, r23
 ac8:	88 1f       	adc	r24, r24
 aca:	bb 1f       	adc	r27, r27
 acc:	26 17       	cp	r18, r22
 ace:	37 07       	cpc	r19, r23
 ad0:	48 07       	cpc	r20, r24
 ad2:	ab 07       	cpc	r26, r27
 ad4:	b0 e8       	ldi	r27, 0x80	; 128
 ad6:	09 f0       	breq	.+2      	; 0xada <__divsf3_pse+0x56>
 ad8:	bb 0b       	sbc	r27, r27
 ada:	80 2d       	mov	r24, r0
 adc:	bf 01       	movw	r22, r30
 ade:	ff 27       	eor	r31, r31
 ae0:	93 58       	subi	r25, 0x83	; 131
 ae2:	5f 4f       	sbci	r21, 0xFF	; 255
 ae4:	3a f0       	brmi	.+14     	; 0xaf4 <__divsf3_pse+0x70>
 ae6:	9e 3f       	cpi	r25, 0xFE	; 254
 ae8:	51 05       	cpc	r21, r1
 aea:	78 f0       	brcs	.+30     	; 0xb0a <__divsf3_pse+0x86>
 aec:	0c 94 10 06 	jmp	0xc20	; 0xc20 <__fp_inf>
 af0:	0c 94 5b 06 	jmp	0xcb6	; 0xcb6 <__fp_szero>
 af4:	5f 3f       	cpi	r21, 0xFF	; 255
 af6:	e4 f3       	brlt	.-8      	; 0xaf0 <__divsf3_pse+0x6c>
 af8:	98 3e       	cpi	r25, 0xE8	; 232
 afa:	d4 f3       	brlt	.-12     	; 0xaf0 <__divsf3_pse+0x6c>
 afc:	86 95       	lsr	r24
 afe:	77 95       	ror	r23
 b00:	67 95       	ror	r22
 b02:	b7 95       	ror	r27
 b04:	f7 95       	ror	r31
 b06:	9f 5f       	subi	r25, 0xFF	; 255
 b08:	c9 f7       	brne	.-14     	; 0xafc <__divsf3_pse+0x78>
 b0a:	88 0f       	add	r24, r24
 b0c:	91 1d       	adc	r25, r1
 b0e:	96 95       	lsr	r25
 b10:	87 95       	ror	r24
 b12:	97 f9       	bld	r25, 7
 b14:	08 95       	ret
 b16:	e1 e0       	ldi	r30, 0x01	; 1
 b18:	66 0f       	add	r22, r22
 b1a:	77 1f       	adc	r23, r23
 b1c:	88 1f       	adc	r24, r24
 b1e:	bb 1f       	adc	r27, r27
 b20:	62 17       	cp	r22, r18
 b22:	73 07       	cpc	r23, r19
 b24:	84 07       	cpc	r24, r20
 b26:	ba 07       	cpc	r27, r26
 b28:	20 f0       	brcs	.+8      	; 0xb32 <__divsf3_pse+0xae>
 b2a:	62 1b       	sub	r22, r18
 b2c:	73 0b       	sbc	r23, r19
 b2e:	84 0b       	sbc	r24, r20
 b30:	ba 0b       	sbc	r27, r26
 b32:	ee 1f       	adc	r30, r30
 b34:	88 f7       	brcc	.-30     	; 0xb18 <__divsf3_pse+0x94>
 b36:	e0 95       	com	r30
 b38:	08 95       	ret

00000b3a <__fixsfsi>:
 b3a:	0e 94 a4 05 	call	0xb48	; 0xb48 <__fixunssfsi>
 b3e:	68 94       	set
 b40:	b1 11       	cpse	r27, r1
 b42:	0c 94 5b 06 	jmp	0xcb6	; 0xcb6 <__fp_szero>
 b46:	08 95       	ret

00000b48 <__fixunssfsi>:
 b48:	0e 94 40 06 	call	0xc80	; 0xc80 <__fp_splitA>
 b4c:	88 f0       	brcs	.+34     	; 0xb70 <__fixunssfsi+0x28>
 b4e:	9f 57       	subi	r25, 0x7F	; 127
 b50:	98 f0       	brcs	.+38     	; 0xb78 <__fixunssfsi+0x30>
 b52:	b9 2f       	mov	r27, r25
 b54:	99 27       	eor	r25, r25
 b56:	b7 51       	subi	r27, 0x17	; 23
 b58:	b0 f0       	brcs	.+44     	; 0xb86 <__fixunssfsi+0x3e>
 b5a:	e1 f0       	breq	.+56     	; 0xb94 <__fixunssfsi+0x4c>
 b5c:	66 0f       	add	r22, r22
 b5e:	77 1f       	adc	r23, r23
 b60:	88 1f       	adc	r24, r24
 b62:	99 1f       	adc	r25, r25
 b64:	1a f0       	brmi	.+6      	; 0xb6c <__fixunssfsi+0x24>
 b66:	ba 95       	dec	r27
 b68:	c9 f7       	brne	.-14     	; 0xb5c <__fixunssfsi+0x14>
 b6a:	14 c0       	rjmp	.+40     	; 0xb94 <__fixunssfsi+0x4c>
 b6c:	b1 30       	cpi	r27, 0x01	; 1
 b6e:	91 f0       	breq	.+36     	; 0xb94 <__fixunssfsi+0x4c>
 b70:	0e 94 5a 06 	call	0xcb4	; 0xcb4 <__fp_zero>
 b74:	b1 e0       	ldi	r27, 0x01	; 1
 b76:	08 95       	ret
 b78:	0c 94 5a 06 	jmp	0xcb4	; 0xcb4 <__fp_zero>
 b7c:	67 2f       	mov	r22, r23
 b7e:	78 2f       	mov	r23, r24
 b80:	88 27       	eor	r24, r24
 b82:	b8 5f       	subi	r27, 0xF8	; 248
 b84:	39 f0       	breq	.+14     	; 0xb94 <__fixunssfsi+0x4c>
 b86:	b9 3f       	cpi	r27, 0xF9	; 249
 b88:	cc f3       	brlt	.-14     	; 0xb7c <__fixunssfsi+0x34>
 b8a:	86 95       	lsr	r24
 b8c:	77 95       	ror	r23
 b8e:	67 95       	ror	r22
 b90:	b3 95       	inc	r27
 b92:	d9 f7       	brne	.-10     	; 0xb8a <__fixunssfsi+0x42>
 b94:	3e f4       	brtc	.+14     	; 0xba4 <__fixunssfsi+0x5c>
 b96:	90 95       	com	r25
 b98:	80 95       	com	r24
 b9a:	70 95       	com	r23
 b9c:	61 95       	neg	r22
 b9e:	7f 4f       	sbci	r23, 0xFF	; 255
 ba0:	8f 4f       	sbci	r24, 0xFF	; 255
 ba2:	9f 4f       	sbci	r25, 0xFF	; 255
 ba4:	08 95       	ret

00000ba6 <__floatunsisf>:
 ba6:	e8 94       	clt
 ba8:	09 c0       	rjmp	.+18     	; 0xbbc <__floatsisf+0x12>

00000baa <__floatsisf>:
 baa:	97 fb       	bst	r25, 7
 bac:	3e f4       	brtc	.+14     	; 0xbbc <__floatsisf+0x12>
 bae:	90 95       	com	r25
 bb0:	80 95       	com	r24
 bb2:	70 95       	com	r23
 bb4:	61 95       	neg	r22
 bb6:	7f 4f       	sbci	r23, 0xFF	; 255
 bb8:	8f 4f       	sbci	r24, 0xFF	; 255
 bba:	9f 4f       	sbci	r25, 0xFF	; 255
 bbc:	99 23       	and	r25, r25
 bbe:	a9 f0       	breq	.+42     	; 0xbea <__floatsisf+0x40>
 bc0:	f9 2f       	mov	r31, r25
 bc2:	96 e9       	ldi	r25, 0x96	; 150
 bc4:	bb 27       	eor	r27, r27
 bc6:	93 95       	inc	r25
 bc8:	f6 95       	lsr	r31
 bca:	87 95       	ror	r24
 bcc:	77 95       	ror	r23
 bce:	67 95       	ror	r22
 bd0:	b7 95       	ror	r27
 bd2:	f1 11       	cpse	r31, r1
 bd4:	f8 cf       	rjmp	.-16     	; 0xbc6 <__floatsisf+0x1c>
 bd6:	fa f4       	brpl	.+62     	; 0xc16 <__floatsisf+0x6c>
 bd8:	bb 0f       	add	r27, r27
 bda:	11 f4       	brne	.+4      	; 0xbe0 <__floatsisf+0x36>
 bdc:	60 ff       	sbrs	r22, 0
 bde:	1b c0       	rjmp	.+54     	; 0xc16 <__floatsisf+0x6c>
 be0:	6f 5f       	subi	r22, 0xFF	; 255
 be2:	7f 4f       	sbci	r23, 0xFF	; 255
 be4:	8f 4f       	sbci	r24, 0xFF	; 255
 be6:	9f 4f       	sbci	r25, 0xFF	; 255
 be8:	16 c0       	rjmp	.+44     	; 0xc16 <__floatsisf+0x6c>
 bea:	88 23       	and	r24, r24
 bec:	11 f0       	breq	.+4      	; 0xbf2 <__floatsisf+0x48>
 bee:	96 e9       	ldi	r25, 0x96	; 150
 bf0:	11 c0       	rjmp	.+34     	; 0xc14 <__floatsisf+0x6a>
 bf2:	77 23       	and	r23, r23
 bf4:	21 f0       	breq	.+8      	; 0xbfe <__floatsisf+0x54>
 bf6:	9e e8       	ldi	r25, 0x8E	; 142
 bf8:	87 2f       	mov	r24, r23
 bfa:	76 2f       	mov	r23, r22
 bfc:	05 c0       	rjmp	.+10     	; 0xc08 <__floatsisf+0x5e>
 bfe:	66 23       	and	r22, r22
 c00:	71 f0       	breq	.+28     	; 0xc1e <__floatsisf+0x74>
 c02:	96 e8       	ldi	r25, 0x86	; 134
 c04:	86 2f       	mov	r24, r22
 c06:	70 e0       	ldi	r23, 0x00	; 0
 c08:	60 e0       	ldi	r22, 0x00	; 0
 c0a:	2a f0       	brmi	.+10     	; 0xc16 <__floatsisf+0x6c>
 c0c:	9a 95       	dec	r25
 c0e:	66 0f       	add	r22, r22
 c10:	77 1f       	adc	r23, r23
 c12:	88 1f       	adc	r24, r24
 c14:	da f7       	brpl	.-10     	; 0xc0c <__floatsisf+0x62>
 c16:	88 0f       	add	r24, r24
 c18:	96 95       	lsr	r25
 c1a:	87 95       	ror	r24
 c1c:	97 f9       	bld	r25, 7
 c1e:	08 95       	ret

00000c20 <__fp_inf>:
 c20:	97 f9       	bld	r25, 7
 c22:	9f 67       	ori	r25, 0x7F	; 127
 c24:	80 e8       	ldi	r24, 0x80	; 128
 c26:	70 e0       	ldi	r23, 0x00	; 0
 c28:	60 e0       	ldi	r22, 0x00	; 0
 c2a:	08 95       	ret

00000c2c <__fp_nan>:
 c2c:	9f ef       	ldi	r25, 0xFF	; 255
 c2e:	80 ec       	ldi	r24, 0xC0	; 192
 c30:	08 95       	ret

00000c32 <__fp_pscA>:
 c32:	00 24       	eor	r0, r0
 c34:	0a 94       	dec	r0
 c36:	16 16       	cp	r1, r22
 c38:	17 06       	cpc	r1, r23
 c3a:	18 06       	cpc	r1, r24
 c3c:	09 06       	cpc	r0, r25
 c3e:	08 95       	ret

00000c40 <__fp_pscB>:
 c40:	00 24       	eor	r0, r0
 c42:	0a 94       	dec	r0
 c44:	12 16       	cp	r1, r18
 c46:	13 06       	cpc	r1, r19
 c48:	14 06       	cpc	r1, r20
 c4a:	05 06       	cpc	r0, r21
 c4c:	08 95       	ret

00000c4e <__fp_round>:
 c4e:	09 2e       	mov	r0, r25
 c50:	03 94       	inc	r0
 c52:	00 0c       	add	r0, r0
 c54:	11 f4       	brne	.+4      	; 0xc5a <__fp_round+0xc>
 c56:	88 23       	and	r24, r24
 c58:	52 f0       	brmi	.+20     	; 0xc6e <__fp_round+0x20>
 c5a:	bb 0f       	add	r27, r27
 c5c:	40 f4       	brcc	.+16     	; 0xc6e <__fp_round+0x20>
 c5e:	bf 2b       	or	r27, r31
 c60:	11 f4       	brne	.+4      	; 0xc66 <__fp_round+0x18>
 c62:	60 ff       	sbrs	r22, 0
 c64:	04 c0       	rjmp	.+8      	; 0xc6e <__fp_round+0x20>
 c66:	6f 5f       	subi	r22, 0xFF	; 255
 c68:	7f 4f       	sbci	r23, 0xFF	; 255
 c6a:	8f 4f       	sbci	r24, 0xFF	; 255
 c6c:	9f 4f       	sbci	r25, 0xFF	; 255
 c6e:	08 95       	ret

00000c70 <__fp_split3>:
 c70:	57 fd       	sbrc	r21, 7
 c72:	90 58       	subi	r25, 0x80	; 128
 c74:	44 0f       	add	r20, r20
 c76:	55 1f       	adc	r21, r21
 c78:	59 f0       	breq	.+22     	; 0xc90 <__fp_splitA+0x10>
 c7a:	5f 3f       	cpi	r21, 0xFF	; 255
 c7c:	71 f0       	breq	.+28     	; 0xc9a <__fp_splitA+0x1a>
 c7e:	47 95       	ror	r20

00000c80 <__fp_splitA>:
 c80:	88 0f       	add	r24, r24
 c82:	97 fb       	bst	r25, 7
 c84:	99 1f       	adc	r25, r25
 c86:	61 f0       	breq	.+24     	; 0xca0 <__fp_splitA+0x20>
 c88:	9f 3f       	cpi	r25, 0xFF	; 255
 c8a:	79 f0       	breq	.+30     	; 0xcaa <__fp_splitA+0x2a>
 c8c:	87 95       	ror	r24
 c8e:	08 95       	ret
 c90:	12 16       	cp	r1, r18
 c92:	13 06       	cpc	r1, r19
 c94:	14 06       	cpc	r1, r20
 c96:	55 1f       	adc	r21, r21
 c98:	f2 cf       	rjmp	.-28     	; 0xc7e <__fp_split3+0xe>
 c9a:	46 95       	lsr	r20
 c9c:	f1 df       	rcall	.-30     	; 0xc80 <__fp_splitA>
 c9e:	08 c0       	rjmp	.+16     	; 0xcb0 <__fp_splitA+0x30>
 ca0:	16 16       	cp	r1, r22
 ca2:	17 06       	cpc	r1, r23
 ca4:	18 06       	cpc	r1, r24
 ca6:	99 1f       	adc	r25, r25
 ca8:	f1 cf       	rjmp	.-30     	; 0xc8c <__fp_splitA+0xc>
 caa:	86 95       	lsr	r24
 cac:	71 05       	cpc	r23, r1
 cae:	61 05       	cpc	r22, r1
 cb0:	08 94       	sec
 cb2:	08 95       	ret

00000cb4 <__fp_zero>:
 cb4:	e8 94       	clt

00000cb6 <__fp_szero>:
 cb6:	bb 27       	eor	r27, r27
 cb8:	66 27       	eor	r22, r22
 cba:	77 27       	eor	r23, r23
 cbc:	cb 01       	movw	r24, r22
 cbe:	97 f9       	bld	r25, 7
 cc0:	08 95       	ret
 cc2:	16 f0       	brts	.+4      	; 0xcc8 <__fp_szero+0x12>
 cc4:	0c 94 1e 07 	jmp	0xe3c	; 0xe3c <__fp_mpack>
 cc8:	0c 94 16 06 	jmp	0xc2c	; 0xc2c <__fp_nan>
 ccc:	68 94       	set
 cce:	0c 94 10 06 	jmp	0xc20	; 0xc20 <__fp_inf>

00000cd2 <log>:
 cd2:	0e 94 40 06 	call	0xc80	; 0xc80 <__fp_splitA>
 cd6:	a8 f3       	brcs	.-22     	; 0xcc2 <__fp_szero+0xc>
 cd8:	99 23       	and	r25, r25
 cda:	c1 f3       	breq	.-16     	; 0xccc <__fp_szero+0x16>
 cdc:	ae f3       	brts	.-22     	; 0xcc8 <__fp_szero+0x12>
 cde:	df 93       	push	r29
 ce0:	cf 93       	push	r28
 ce2:	1f 93       	push	r17
 ce4:	0f 93       	push	r16
 ce6:	ff 92       	push	r15
 ce8:	c9 2f       	mov	r28, r25
 cea:	dd 27       	eor	r29, r29
 cec:	88 23       	and	r24, r24
 cee:	2a f0       	brmi	.+10     	; 0xcfa <log+0x28>
 cf0:	21 97       	sbiw	r28, 0x01	; 1
 cf2:	66 0f       	add	r22, r22
 cf4:	77 1f       	adc	r23, r23
 cf6:	88 1f       	adc	r24, r24
 cf8:	da f7       	brpl	.-10     	; 0xcf0 <log+0x1e>
 cfa:	20 e0       	ldi	r18, 0x00	; 0
 cfc:	30 e0       	ldi	r19, 0x00	; 0
 cfe:	40 e8       	ldi	r20, 0x80	; 128
 d00:	5f eb       	ldi	r21, 0xBF	; 191
 d02:	9f e3       	ldi	r25, 0x3F	; 63
 d04:	88 39       	cpi	r24, 0x98	; 152
 d06:	20 f0       	brcs	.+8      	; 0xd10 <log+0x3e>
 d08:	80 3e       	cpi	r24, 0xE0	; 224
 d0a:	38 f0       	brcs	.+14     	; 0xd1a <log+0x48>
 d0c:	21 96       	adiw	r28, 0x01	; 1
 d0e:	8f 77       	andi	r24, 0x7F	; 127
 d10:	0e 94 bf 04 	call	0x97e	; 0x97e <__addsf3>
 d14:	e4 eb       	ldi	r30, 0xB4	; 180
 d16:	f0 e0       	ldi	r31, 0x00	; 0
 d18:	04 c0       	rjmp	.+8      	; 0xd22 <log+0x50>
 d1a:	0e 94 bf 04 	call	0x97e	; 0x97e <__addsf3>
 d1e:	e1 ee       	ldi	r30, 0xE1	; 225
 d20:	f0 e0       	ldi	r31, 0x00	; 0
 d22:	0e 94 2c 07 	call	0xe58	; 0xe58 <__fp_powser>
 d26:	8b 01       	movw	r16, r22
 d28:	be 01       	movw	r22, r28
 d2a:	ec 01       	movw	r28, r24
 d2c:	fb 2e       	mov	r15, r27
 d2e:	6f 57       	subi	r22, 0x7F	; 127
 d30:	71 09       	sbc	r23, r1
 d32:	75 95       	asr	r23
 d34:	77 1f       	adc	r23, r23
 d36:	88 0b       	sbc	r24, r24
 d38:	99 0b       	sbc	r25, r25
 d3a:	0e 94 d5 05 	call	0xbaa	; 0xbaa <__floatsisf>
 d3e:	28 e1       	ldi	r18, 0x18	; 24
 d40:	32 e7       	ldi	r19, 0x72	; 114
 d42:	41 e3       	ldi	r20, 0x31	; 49
 d44:	5f e3       	ldi	r21, 0x3F	; 63
 d46:	0e 94 c4 06 	call	0xd88	; 0xd88 <__mulsf3x>
 d4a:	af 2d       	mov	r26, r15
 d4c:	98 01       	movw	r18, r16
 d4e:	ae 01       	movw	r20, r28
 d50:	ff 90       	pop	r15
 d52:	0f 91       	pop	r16
 d54:	1f 91       	pop	r17
 d56:	cf 91       	pop	r28
 d58:	df 91       	pop	r29
 d5a:	0e 94 d6 04 	call	0x9ac	; 0x9ac <__addsf3x>
 d5e:	0c 94 27 06 	jmp	0xc4e	; 0xc4e <__fp_round>

00000d62 <__mulsf3>:
 d62:	0e 94 c4 06 	call	0xd88	; 0xd88 <__mulsf3x>
 d66:	0c 94 27 06 	jmp	0xc4e	; 0xc4e <__fp_round>
 d6a:	0e 94 19 06 	call	0xc32	; 0xc32 <__fp_pscA>
 d6e:	38 f0       	brcs	.+14     	; 0xd7e <__mulsf3+0x1c>
 d70:	0e 94 20 06 	call	0xc40	; 0xc40 <__fp_pscB>
 d74:	20 f0       	brcs	.+8      	; 0xd7e <__mulsf3+0x1c>
 d76:	95 23       	and	r25, r21
 d78:	11 f0       	breq	.+4      	; 0xd7e <__mulsf3+0x1c>
 d7a:	0c 94 10 06 	jmp	0xc20	; 0xc20 <__fp_inf>
 d7e:	0c 94 16 06 	jmp	0xc2c	; 0xc2c <__fp_nan>
 d82:	11 24       	eor	r1, r1
 d84:	0c 94 5b 06 	jmp	0xcb6	; 0xcb6 <__fp_szero>

00000d88 <__mulsf3x>:
 d88:	0e 94 38 06 	call	0xc70	; 0xc70 <__fp_split3>
 d8c:	70 f3       	brcs	.-36     	; 0xd6a <__mulsf3+0x8>

00000d8e <__mulsf3_pse>:
 d8e:	95 9f       	mul	r25, r21
 d90:	c1 f3       	breq	.-16     	; 0xd82 <__mulsf3+0x20>
 d92:	95 0f       	add	r25, r21
 d94:	50 e0       	ldi	r21, 0x00	; 0
 d96:	55 1f       	adc	r21, r21
 d98:	62 9f       	mul	r22, r18
 d9a:	f0 01       	movw	r30, r0
 d9c:	72 9f       	mul	r23, r18
 d9e:	bb 27       	eor	r27, r27
 da0:	f0 0d       	add	r31, r0
 da2:	b1 1d       	adc	r27, r1
 da4:	63 9f       	mul	r22, r19
 da6:	aa 27       	eor	r26, r26
 da8:	f0 0d       	add	r31, r0
 daa:	b1 1d       	adc	r27, r1
 dac:	aa 1f       	adc	r26, r26
 dae:	64 9f       	mul	r22, r20
 db0:	66 27       	eor	r22, r22
 db2:	b0 0d       	add	r27, r0
 db4:	a1 1d       	adc	r26, r1
 db6:	66 1f       	adc	r22, r22
 db8:	82 9f       	mul	r24, r18
 dba:	22 27       	eor	r18, r18
 dbc:	b0 0d       	add	r27, r0
 dbe:	a1 1d       	adc	r26, r1
 dc0:	62 1f       	adc	r22, r18
 dc2:	73 9f       	mul	r23, r19
 dc4:	b0 0d       	add	r27, r0
 dc6:	a1 1d       	adc	r26, r1
 dc8:	62 1f       	adc	r22, r18
 dca:	83 9f       	mul	r24, r19
 dcc:	a0 0d       	add	r26, r0
 dce:	61 1d       	adc	r22, r1
 dd0:	22 1f       	adc	r18, r18
 dd2:	74 9f       	mul	r23, r20
 dd4:	33 27       	eor	r19, r19
 dd6:	a0 0d       	add	r26, r0
 dd8:	61 1d       	adc	r22, r1
 dda:	23 1f       	adc	r18, r19
 ddc:	84 9f       	mul	r24, r20
 dde:	60 0d       	add	r22, r0
 de0:	21 1d       	adc	r18, r1
 de2:	82 2f       	mov	r24, r18
 de4:	76 2f       	mov	r23, r22
 de6:	6a 2f       	mov	r22, r26
 de8:	11 24       	eor	r1, r1
 dea:	9f 57       	subi	r25, 0x7F	; 127
 dec:	50 40       	sbci	r21, 0x00	; 0
 dee:	9a f0       	brmi	.+38     	; 0xe16 <__mulsf3_pse+0x88>
 df0:	f1 f0       	breq	.+60     	; 0xe2e <__mulsf3_pse+0xa0>
 df2:	88 23       	and	r24, r24
 df4:	4a f0       	brmi	.+18     	; 0xe08 <__mulsf3_pse+0x7a>
 df6:	ee 0f       	add	r30, r30
 df8:	ff 1f       	adc	r31, r31
 dfa:	bb 1f       	adc	r27, r27
 dfc:	66 1f       	adc	r22, r22
 dfe:	77 1f       	adc	r23, r23
 e00:	88 1f       	adc	r24, r24
 e02:	91 50       	subi	r25, 0x01	; 1
 e04:	50 40       	sbci	r21, 0x00	; 0
 e06:	a9 f7       	brne	.-22     	; 0xdf2 <__mulsf3_pse+0x64>
 e08:	9e 3f       	cpi	r25, 0xFE	; 254
 e0a:	51 05       	cpc	r21, r1
 e0c:	80 f0       	brcs	.+32     	; 0xe2e <__mulsf3_pse+0xa0>
 e0e:	0c 94 10 06 	jmp	0xc20	; 0xc20 <__fp_inf>
 e12:	0c 94 5b 06 	jmp	0xcb6	; 0xcb6 <__fp_szero>
 e16:	5f 3f       	cpi	r21, 0xFF	; 255
 e18:	e4 f3       	brlt	.-8      	; 0xe12 <__mulsf3_pse+0x84>
 e1a:	98 3e       	cpi	r25, 0xE8	; 232
 e1c:	d4 f3       	brlt	.-12     	; 0xe12 <__mulsf3_pse+0x84>
 e1e:	86 95       	lsr	r24
 e20:	77 95       	ror	r23
 e22:	67 95       	ror	r22
 e24:	b7 95       	ror	r27
 e26:	f7 95       	ror	r31
 e28:	e7 95       	ror	r30
 e2a:	9f 5f       	subi	r25, 0xFF	; 255
 e2c:	c1 f7       	brne	.-16     	; 0xe1e <__mulsf3_pse+0x90>
 e2e:	fe 2b       	or	r31, r30
 e30:	88 0f       	add	r24, r24
 e32:	91 1d       	adc	r25, r1
 e34:	96 95       	lsr	r25
 e36:	87 95       	ror	r24
 e38:	97 f9       	bld	r25, 7
 e3a:	08 95       	ret

00000e3c <__fp_mpack>:
 e3c:	9f 3f       	cpi	r25, 0xFF	; 255
 e3e:	31 f0       	breq	.+12     	; 0xe4c <__fp_mpack_finite+0xc>

00000e40 <__fp_mpack_finite>:
 e40:	91 50       	subi	r25, 0x01	; 1
 e42:	20 f4       	brcc	.+8      	; 0xe4c <__fp_mpack_finite+0xc>
 e44:	87 95       	ror	r24
 e46:	77 95       	ror	r23
 e48:	67 95       	ror	r22
 e4a:	b7 95       	ror	r27
 e4c:	88 0f       	add	r24, r24
 e4e:	91 1d       	adc	r25, r1
 e50:	96 95       	lsr	r25
 e52:	87 95       	ror	r24
 e54:	97 f9       	bld	r25, 7
 e56:	08 95       	ret

00000e58 <__fp_powser>:
 e58:	df 93       	push	r29
 e5a:	cf 93       	push	r28
 e5c:	1f 93       	push	r17
 e5e:	0f 93       	push	r16
 e60:	ff 92       	push	r15
 e62:	ef 92       	push	r14
 e64:	df 92       	push	r13
 e66:	7b 01       	movw	r14, r22
 e68:	8c 01       	movw	r16, r24
 e6a:	68 94       	set
 e6c:	06 c0       	rjmp	.+12     	; 0xe7a <__fp_powser+0x22>
 e6e:	da 2e       	mov	r13, r26
 e70:	ef 01       	movw	r28, r30
 e72:	0e 94 c4 06 	call	0xd88	; 0xd88 <__mulsf3x>
 e76:	fe 01       	movw	r30, r28
 e78:	e8 94       	clt
 e7a:	a5 91       	lpm	r26, Z+
 e7c:	25 91       	lpm	r18, Z+
 e7e:	35 91       	lpm	r19, Z+
 e80:	45 91       	lpm	r20, Z+
 e82:	55 91       	lpm	r21, Z+
 e84:	a6 f3       	brts	.-24     	; 0xe6e <__fp_powser+0x16>
 e86:	ef 01       	movw	r28, r30
 e88:	0e 94 d6 04 	call	0x9ac	; 0x9ac <__addsf3x>
 e8c:	fe 01       	movw	r30, r28
 e8e:	97 01       	movw	r18, r14
 e90:	a8 01       	movw	r20, r16
 e92:	da 94       	dec	r13
 e94:	69 f7       	brne	.-38     	; 0xe70 <__fp_powser+0x18>
 e96:	df 90       	pop	r13
 e98:	ef 90       	pop	r14
 e9a:	ff 90       	pop	r15
 e9c:	0f 91       	pop	r16
 e9e:	1f 91       	pop	r17
 ea0:	cf 91       	pop	r28
 ea2:	df 91       	pop	r29
 ea4:	08 95       	ret

00000ea6 <__divmodhi4>:
 ea6:	97 fb       	bst	r25, 7
 ea8:	07 2e       	mov	r0, r23
 eaa:	16 f4       	brtc	.+4      	; 0xeb0 <__divmodhi4+0xa>
 eac:	00 94       	com	r0
 eae:	07 d0       	rcall	.+14     	; 0xebe <__divmodhi4_neg1>
 eb0:	77 fd       	sbrc	r23, 7
 eb2:	09 d0       	rcall	.+18     	; 0xec6 <__divmodhi4_neg2>
 eb4:	0e 94 67 07 	call	0xece	; 0xece <__udivmodhi4>
 eb8:	07 fc       	sbrc	r0, 7
 eba:	05 d0       	rcall	.+10     	; 0xec6 <__divmodhi4_neg2>
 ebc:	3e f4       	brtc	.+14     	; 0xecc <__divmodhi4_exit>

00000ebe <__divmodhi4_neg1>:
 ebe:	90 95       	com	r25
 ec0:	81 95       	neg	r24
 ec2:	9f 4f       	sbci	r25, 0xFF	; 255
 ec4:	08 95       	ret

00000ec6 <__divmodhi4_neg2>:
 ec6:	70 95       	com	r23
 ec8:	61 95       	neg	r22
 eca:	7f 4f       	sbci	r23, 0xFF	; 255

00000ecc <__divmodhi4_exit>:
 ecc:	08 95       	ret

00000ece <__udivmodhi4>:
 ece:	aa 1b       	sub	r26, r26
 ed0:	bb 1b       	sub	r27, r27
 ed2:	51 e1       	ldi	r21, 0x11	; 17
 ed4:	07 c0       	rjmp	.+14     	; 0xee4 <__udivmodhi4_ep>

00000ed6 <__udivmodhi4_loop>:
 ed6:	aa 1f       	adc	r26, r26
 ed8:	bb 1f       	adc	r27, r27
 eda:	a6 17       	cp	r26, r22
 edc:	b7 07       	cpc	r27, r23
 ede:	10 f0       	brcs	.+4      	; 0xee4 <__udivmodhi4_ep>
 ee0:	a6 1b       	sub	r26, r22
 ee2:	b7 0b       	sbc	r27, r23

00000ee4 <__udivmodhi4_ep>:
 ee4:	88 1f       	adc	r24, r24
 ee6:	99 1f       	adc	r25, r25
 ee8:	5a 95       	dec	r21
 eea:	a9 f7       	brne	.-22     	; 0xed6 <__udivmodhi4_loop>
 eec:	80 95       	com	r24
 eee:	90 95       	com	r25
 ef0:	bc 01       	movw	r22, r24
 ef2:	cd 01       	movw	r24, r26
 ef4:	08 95       	ret

00000ef6 <_exit>:
 ef6:	f8 94       	cli

00000ef8 <__stop_program>:
 ef8:	ff cf       	rjmp	.-2      	; 0xef8 <__stop_program>
